# Generated from grammar/Teradata.G4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5: # for >python3.5
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,466,830,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,1,0,1,0,3,0,139,8,0,1,0,1,0,1,1,1,1,1,1,1,
        2,1,2,1,2,4,2,149,8,2,11,2,12,2,150,1,3,1,3,3,3,155,8,3,1,4,1,4,
        1,4,1,4,1,4,1,4,3,4,163,8,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,3,4,172,
        8,4,1,5,1,5,1,5,1,5,3,5,178,8,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
        1,5,1,5,3,5,190,8,5,1,5,3,5,193,8,5,1,5,1,5,3,5,197,8,5,1,5,3,5,
        200,8,5,1,5,3,5,203,8,5,1,5,1,5,1,5,3,5,208,8,5,1,5,3,5,211,8,5,
        1,5,1,5,1,5,1,5,3,5,217,8,5,1,5,1,5,1,5,1,5,3,5,223,8,5,3,5,225,
        8,5,1,6,1,6,3,6,229,8,6,1,6,1,6,1,6,1,7,3,7,235,8,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,250,8,7,1,7,1,7,3,7,
        254,8,7,1,7,1,7,3,7,258,8,7,1,8,1,8,3,8,262,8,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,3,8,271,8,8,3,8,273,8,8,1,9,1,9,1,9,3,9,278,8,9,1,9,
        1,9,3,9,282,8,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,292,
        8,10,1,11,1,11,1,11,1,11,5,11,298,8,11,10,11,12,11,301,9,11,3,11,
        303,8,11,1,12,1,12,3,12,307,8,12,1,12,3,12,310,8,12,1,12,1,12,1,
        12,1,12,3,12,316,8,12,1,13,1,13,1,13,1,14,1,14,5,14,323,8,14,10,
        14,12,14,326,9,14,1,15,1,15,1,15,1,15,3,15,332,8,15,1,15,1,15,1,
        15,1,15,1,15,3,15,339,8,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,347,
        8,15,1,15,1,15,1,15,1,15,1,15,3,15,354,8,15,1,15,1,15,1,15,1,15,
        1,15,1,15,3,15,362,8,15,3,15,364,8,15,1,16,1,16,1,16,3,16,369,8,
        16,1,17,1,17,3,17,373,8,17,1,17,3,17,376,8,17,1,17,3,17,379,8,17,
        1,18,1,18,1,18,3,18,384,8,18,3,18,386,8,18,1,18,1,18,1,18,3,18,391,
        8,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,401,8,18,1,19,
        1,19,1,19,1,19,3,19,407,8,19,1,19,1,19,1,19,1,19,1,19,3,19,414,8,
        19,1,20,1,20,1,20,1,20,1,20,3,20,421,8,20,1,20,1,20,1,20,3,20,426,
        8,20,1,20,1,20,1,20,1,20,1,20,3,20,433,8,20,1,21,1,21,1,21,1,21,
        1,21,3,21,440,8,21,1,21,1,21,1,21,3,21,445,8,21,5,21,447,8,21,10,
        21,12,21,450,9,21,3,21,452,8,21,1,22,1,22,1,22,1,22,1,22,1,22,1,
        22,1,22,1,22,1,22,1,22,3,22,465,8,22,3,22,467,8,22,1,23,1,23,1,23,
        1,24,1,24,1,24,1,25,1,25,1,25,1,26,1,26,1,27,1,27,1,28,1,28,1,28,
        5,28,485,8,28,10,28,12,28,488,9,28,1,29,1,29,1,29,1,29,1,29,3,29,
        495,8,29,1,30,1,30,1,30,5,30,500,8,30,10,30,12,30,503,9,30,1,31,
        1,31,1,31,1,31,3,31,509,8,31,1,32,1,32,3,32,513,8,32,1,32,1,32,1,
        32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,526,8,32,1,32,3,
        32,529,8,32,1,32,1,32,1,32,1,32,3,32,535,8,32,3,32,537,8,32,3,32,
        539,8,32,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,550,8,
        33,1,33,1,33,1,33,5,33,555,8,33,10,33,12,33,558,9,33,1,33,3,33,561,
        8,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,
        1,33,1,33,1,33,3,33,578,8,33,1,33,1,33,1,33,1,33,1,33,4,33,585,8,
        33,11,33,12,33,586,1,33,1,33,3,33,591,8,33,1,33,1,33,3,33,595,8,
        33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,
        33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,619,8,33,1,
        33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,631,8,33,1,
        33,1,33,1,33,3,33,636,8,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,
        33,645,8,33,1,33,1,33,1,33,1,33,3,33,651,8,33,1,33,1,33,1,33,1,33,
        1,33,1,33,1,33,1,33,3,33,661,8,33,1,33,1,33,3,33,665,8,33,1,33,1,
        33,1,33,1,33,1,33,1,33,5,33,673,8,33,10,33,12,33,676,9,33,3,33,678,
        8,33,1,33,1,33,1,33,1,33,3,33,684,8,33,1,33,3,33,687,8,33,5,33,689,
        8,33,10,33,12,33,692,9,33,1,34,1,34,1,34,5,34,697,8,34,10,34,12,
        34,700,9,34,1,35,1,35,1,35,3,35,705,8,35,1,36,1,36,1,36,1,37,1,37,
        1,38,1,38,1,39,1,39,1,40,1,40,1,41,1,41,1,42,1,42,1,43,1,43,1,44,
        1,44,1,44,5,44,727,8,44,10,44,12,44,730,9,44,1,45,3,45,733,8,45,
        1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,746,
        8,46,1,47,1,47,1,48,1,48,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,
        1,53,1,53,1,54,3,54,763,8,54,1,54,1,54,3,54,767,8,54,1,55,3,55,770,
        8,55,1,55,1,55,1,56,3,56,775,8,56,1,56,1,56,1,57,1,57,3,57,781,8,
        57,1,58,1,58,1,59,1,59,1,60,1,60,3,60,789,8,60,1,61,1,61,1,62,1,
        62,1,62,3,62,796,8,62,1,62,1,62,1,63,1,63,1,63,3,63,803,8,63,1,63,
        1,63,1,64,1,64,1,65,1,65,1,65,4,65,812,8,65,11,65,12,65,813,1,65,
        3,65,817,8,65,1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,
        828,8,67,1,67,0,1,66,68,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
        114,116,118,120,122,124,126,128,130,132,134,0,13,2,0,311,311,317,
        317,2,0,145,145,212,212,2,0,231,231,237,237,1,0,458,459,3,0,45,45,
        233,233,345,345,2,0,103,103,242,242,2,0,7,7,12,13,1,0,8,9,1,0,18,
        21,2,0,8,10,208,208,1,0,25,451,3,0,5,5,457,457,462,462,18,0,122,
        122,150,150,152,152,156,156,170,170,176,176,235,235,238,238,249,
        249,254,255,265,265,271,271,318,319,324,324,331,331,377,377,428,
        428,451,451,922,0,138,1,0,0,0,2,142,1,0,0,0,4,148,1,0,0,0,6,154,
        1,0,0,0,8,171,1,0,0,0,10,173,1,0,0,0,12,226,1,0,0,0,14,257,1,0,0,
        0,16,259,1,0,0,0,18,274,1,0,0,0,20,291,1,0,0,0,22,302,1,0,0,0,24,
        315,1,0,0,0,26,317,1,0,0,0,28,320,1,0,0,0,30,363,1,0,0,0,32,368,
        1,0,0,0,34,370,1,0,0,0,36,400,1,0,0,0,38,402,1,0,0,0,40,415,1,0,
        0,0,42,434,1,0,0,0,44,466,1,0,0,0,46,468,1,0,0,0,48,471,1,0,0,0,
        50,474,1,0,0,0,52,477,1,0,0,0,54,479,1,0,0,0,56,481,1,0,0,0,58,494,
        1,0,0,0,60,496,1,0,0,0,62,508,1,0,0,0,64,538,1,0,0,0,66,594,1,0,
        0,0,68,693,1,0,0,0,70,704,1,0,0,0,72,706,1,0,0,0,74,709,1,0,0,0,
        76,711,1,0,0,0,78,713,1,0,0,0,80,715,1,0,0,0,82,717,1,0,0,0,84,719,
        1,0,0,0,86,721,1,0,0,0,88,723,1,0,0,0,90,732,1,0,0,0,92,745,1,0,
        0,0,94,747,1,0,0,0,96,749,1,0,0,0,98,751,1,0,0,0,100,753,1,0,0,0,
        102,755,1,0,0,0,104,757,1,0,0,0,106,759,1,0,0,0,108,766,1,0,0,0,
        110,769,1,0,0,0,112,774,1,0,0,0,114,780,1,0,0,0,116,782,1,0,0,0,
        118,784,1,0,0,0,120,788,1,0,0,0,122,790,1,0,0,0,124,795,1,0,0,0,
        126,802,1,0,0,0,128,806,1,0,0,0,130,808,1,0,0,0,132,818,1,0,0,0,
        134,827,1,0,0,0,136,139,3,4,2,0,137,139,3,2,1,0,138,136,1,0,0,0,
        138,137,1,0,0,0,139,140,1,0,0,0,140,141,5,0,0,1,141,1,1,0,0,0,142,
        143,5,466,0,0,143,144,6,1,-1,0,144,3,1,0,0,0,145,146,3,6,3,0,146,
        147,5,1,0,0,147,149,1,0,0,0,148,145,1,0,0,0,149,150,1,0,0,0,150,
        148,1,0,0,0,150,151,1,0,0,0,151,5,1,0,0,0,152,155,3,8,4,0,153,155,
        3,12,6,0,154,152,1,0,0,0,154,153,1,0,0,0,155,7,1,0,0,0,156,157,5,
        396,0,0,157,162,3,98,49,0,158,159,5,3,0,0,159,160,3,88,44,0,160,
        161,5,4,0,0,161,163,1,0,0,0,162,158,1,0,0,0,162,163,1,0,0,0,163,
        164,1,0,0,0,164,165,5,139,0,0,165,166,5,3,0,0,166,167,3,10,5,0,167,
        168,5,4,0,0,168,169,3,10,5,0,169,172,1,0,0,0,170,172,3,10,5,0,171,
        156,1,0,0,0,171,170,1,0,0,0,172,9,1,0,0,0,173,192,7,0,0,0,174,178,
        5,242,0,0,175,178,5,103,0,0,176,178,3,44,22,0,177,174,1,0,0,0,177,
        175,1,0,0,0,177,176,1,0,0,0,178,189,1,0,0,0,179,180,3,124,62,0,180,
        181,5,2,0,0,181,182,5,7,0,0,182,183,5,2,0,0,183,184,5,103,0,0,184,
        190,1,0,0,0,185,186,3,126,63,0,186,187,5,2,0,0,187,188,5,103,0,0,
        188,190,1,0,0,0,189,179,1,0,0,0,189,185,1,0,0,0,189,190,1,0,0,0,
        190,193,1,0,0,0,191,193,3,18,9,0,192,177,1,0,0,0,192,191,1,0,0,0,
        192,193,1,0,0,0,193,194,1,0,0,0,194,196,3,22,11,0,195,197,3,26,13,
        0,196,195,1,0,0,0,196,197,1,0,0,0,197,199,1,0,0,0,198,200,3,42,21,
        0,199,198,1,0,0,0,199,200,1,0,0,0,200,202,1,0,0,0,201,203,3,46,23,
        0,202,201,1,0,0,0,202,203,1,0,0,0,203,207,1,0,0,0,204,205,5,99,0,
        0,205,206,5,259,0,0,206,208,3,56,28,0,207,204,1,0,0,0,207,208,1,
        0,0,0,208,210,1,0,0,0,209,211,3,20,10,0,210,209,1,0,0,0,210,211,
        1,0,0,0,211,224,1,0,0,0,212,213,5,310,0,0,213,214,5,259,0,0,214,
        216,3,60,30,0,215,217,7,1,0,0,216,215,1,0,0,0,216,217,1,0,0,0,217,
        222,1,0,0,0,218,219,5,455,0,0,219,223,5,422,0,0,220,221,5,455,0,
        0,221,223,5,454,0,0,222,218,1,0,0,0,222,220,1,0,0,0,222,223,1,0,
        0,0,223,225,1,0,0,0,224,212,1,0,0,0,224,225,1,0,0,0,225,11,1,0,0,
        0,226,228,7,2,0,0,227,229,5,279,0,0,228,227,1,0,0,0,228,229,1,0,
        0,0,229,230,1,0,0,0,230,231,3,124,62,0,231,232,3,14,7,0,232,13,1,
        0,0,0,233,235,5,312,0,0,234,233,1,0,0,0,234,235,1,0,0,0,235,236,
        1,0,0,0,236,237,5,3,0,0,237,238,3,68,34,0,238,239,5,4,0,0,239,258,
        1,0,0,0,240,241,5,3,0,0,241,242,3,88,44,0,242,243,5,4,0,0,243,244,
        5,312,0,0,244,245,5,3,0,0,245,246,3,68,34,0,246,247,5,4,0,0,247,
        258,1,0,0,0,248,250,3,88,44,0,249,248,1,0,0,0,249,250,1,0,0,0,250,
        251,1,0,0,0,251,253,3,82,41,0,252,254,3,16,8,0,253,252,1,0,0,0,253,
        254,1,0,0,0,254,258,1,0,0,0,255,256,5,188,0,0,256,258,5,312,0,0,
        257,234,1,0,0,0,257,240,1,0,0,0,257,249,1,0,0,0,257,255,1,0,0,0,
        258,15,1,0,0,0,259,261,5,405,0,0,260,262,5,103,0,0,261,260,1,0,0,
        0,261,262,1,0,0,0,262,263,1,0,0,0,263,272,5,456,0,0,264,270,5,396,
        0,0,265,266,5,196,0,0,266,271,5,357,0,0,267,268,5,357,0,0,268,269,
        5,256,0,0,269,271,5,457,0,0,270,265,1,0,0,0,270,267,1,0,0,0,271,
        273,1,0,0,0,272,264,1,0,0,0,272,273,1,0,0,0,273,17,1,0,0,0,274,275,
        5,447,0,0,275,277,7,3,0,0,276,278,5,358,0,0,277,276,1,0,0,0,277,
        278,1,0,0,0,278,281,1,0,0,0,279,280,5,396,0,0,280,282,5,448,0,0,
        281,279,1,0,0,0,281,282,1,0,0,0,282,19,1,0,0,0,283,292,3,48,24,0,
        284,292,3,50,25,0,285,286,3,48,24,0,286,287,3,50,25,0,287,292,1,
        0,0,0,288,289,3,50,25,0,289,290,3,48,24,0,290,292,1,0,0,0,291,283,
        1,0,0,0,291,284,1,0,0,0,291,285,1,0,0,0,291,288,1,0,0,0,292,21,1,
        0,0,0,293,303,5,7,0,0,294,299,3,24,12,0,295,296,5,5,0,0,296,298,
        3,24,12,0,297,295,1,0,0,0,298,301,1,0,0,0,299,297,1,0,0,0,299,300,
        1,0,0,0,300,303,1,0,0,0,301,299,1,0,0,0,302,293,1,0,0,0,302,294,
        1,0,0,0,303,23,1,0,0,0,304,309,3,66,33,0,305,307,5,139,0,0,306,305,
        1,0,0,0,306,307,1,0,0,0,307,308,1,0,0,0,308,310,3,100,50,0,309,306,
        1,0,0,0,309,310,1,0,0,0,310,316,1,0,0,0,311,312,3,124,62,0,312,313,
        5,2,0,0,313,314,5,7,0,0,314,316,1,0,0,0,315,304,1,0,0,0,315,311,
        1,0,0,0,316,25,1,0,0,0,317,318,5,39,0,0,318,319,3,28,14,0,319,27,
        1,0,0,0,320,324,3,32,16,0,321,323,3,36,18,0,322,321,1,0,0,0,323,
        326,1,0,0,0,324,322,1,0,0,0,324,325,1,0,0,0,325,29,1,0,0,0,326,324,
        1,0,0,0,327,328,5,139,0,0,328,331,5,256,0,0,329,332,3,108,54,0,330,
        332,3,110,55,0,331,329,1,0,0,0,331,330,1,0,0,0,331,332,1,0,0,0,332,
        364,1,0,0,0,333,334,5,449,0,0,334,335,5,139,0,0,335,338,5,256,0,
        0,336,339,3,108,54,0,337,339,3,110,55,0,338,336,1,0,0,0,338,337,
        1,0,0,0,338,339,1,0,0,0,339,340,1,0,0,0,340,341,5,121,0,0,341,342,
        5,450,0,0,342,343,5,139,0,0,343,346,5,256,0,0,344,347,3,108,54,0,
        345,347,3,110,55,0,346,344,1,0,0,0,346,345,1,0,0,0,346,347,1,0,0,
        0,347,364,1,0,0,0,348,349,5,450,0,0,349,350,5,139,0,0,350,353,5,
        256,0,0,351,354,3,108,54,0,352,354,3,110,55,0,353,351,1,0,0,0,353,
        352,1,0,0,0,353,354,1,0,0,0,354,355,1,0,0,0,355,356,5,121,0,0,356,
        357,5,449,0,0,357,358,5,139,0,0,358,361,5,256,0,0,359,362,3,108,
        54,0,360,362,3,110,55,0,361,359,1,0,0,0,361,360,1,0,0,0,361,362,
        1,0,0,0,362,364,1,0,0,0,363,327,1,0,0,0,363,333,1,0,0,0,363,348,
        1,0,0,0,364,31,1,0,0,0,365,369,3,34,17,0,366,369,3,38,19,0,367,369,
        3,40,20,0,368,365,1,0,0,0,368,366,1,0,0,0,368,367,1,0,0,0,369,33,
        1,0,0,0,370,372,3,124,62,0,371,373,3,30,15,0,372,371,1,0,0,0,372,
        373,1,0,0,0,373,378,1,0,0,0,374,376,5,139,0,0,375,374,1,0,0,0,375,
        376,1,0,0,0,376,377,1,0,0,0,377,379,3,128,64,0,378,375,1,0,0,0,378,
        379,1,0,0,0,379,35,1,0,0,0,380,386,5,213,0,0,381,383,7,4,0,0,382,
        384,5,322,0,0,383,382,1,0,0,0,383,384,1,0,0,0,384,386,1,0,0,0,385,
        380,1,0,0,0,385,381,1,0,0,0,386,387,1,0,0,0,387,388,5,297,0,0,388,
        390,3,32,16,0,389,391,3,30,15,0,390,389,1,0,0,0,390,391,1,0,0,0,
        391,392,1,0,0,0,392,393,5,280,0,0,393,394,3,84,42,0,394,401,1,0,
        0,0,395,396,5,74,0,0,396,397,5,297,0,0,397,401,3,32,16,0,398,399,
        5,5,0,0,399,401,3,32,16,0,400,385,1,0,0,0,400,395,1,0,0,0,400,398,
        1,0,0,0,401,37,1,0,0,0,402,403,5,3,0,0,403,404,3,82,41,0,404,406,
        5,4,0,0,405,407,5,139,0,0,406,405,1,0,0,0,406,407,1,0,0,0,407,408,
        1,0,0,0,408,413,3,106,53,0,409,410,5,3,0,0,410,411,3,88,44,0,411,
        412,5,4,0,0,412,414,1,0,0,0,413,409,1,0,0,0,413,414,1,0,0,0,414,
        39,1,0,0,0,415,416,5,102,0,0,416,417,5,3,0,0,417,418,3,120,60,0,
        418,420,5,3,0,0,419,421,3,68,34,0,420,419,1,0,0,0,420,421,1,0,0,
        0,421,422,1,0,0,0,422,423,5,4,0,0,423,425,5,4,0,0,424,426,5,139,
        0,0,425,424,1,0,0,0,425,426,1,0,0,0,426,427,1,0,0,0,427,432,3,106,
        53,0,428,429,5,3,0,0,429,430,3,88,44,0,430,431,5,4,0,0,431,433,1,
        0,0,0,432,428,1,0,0,0,432,433,1,0,0,0,433,41,1,0,0,0,434,435,5,396,
        0,0,435,451,3,68,34,0,436,437,5,259,0,0,437,439,3,66,33,0,438,440,
        7,1,0,0,439,438,1,0,0,0,439,440,1,0,0,0,440,448,1,0,0,0,441,442,
        5,5,0,0,442,444,3,66,33,0,443,445,7,1,0,0,444,443,1,0,0,0,444,445,
        1,0,0,0,445,447,1,0,0,0,446,441,1,0,0,0,447,450,1,0,0,0,448,446,
        1,0,0,0,448,449,1,0,0,0,449,452,1,0,0,0,450,448,1,0,0,0,451,436,
        1,0,0,0,451,452,1,0,0,0,452,43,1,0,0,0,453,467,5,452,0,0,454,455,
        5,452,0,0,455,456,5,280,0,0,456,457,5,453,0,0,457,458,5,304,0,0,
        458,467,5,334,0,0,459,460,5,452,0,0,460,461,5,280,0,0,461,464,5,
        334,0,0,462,463,5,304,0,0,463,465,5,453,0,0,464,462,1,0,0,0,464,
        465,1,0,0,0,465,467,1,0,0,0,466,453,1,0,0,0,466,454,1,0,0,0,466,
        459,1,0,0,0,467,45,1,0,0,0,468,469,5,378,0,0,469,470,3,84,42,0,470,
        47,1,0,0,0,471,472,5,147,0,0,472,473,3,86,43,0,473,49,1,0,0,0,474,
        475,5,35,0,0,475,476,3,84,42,0,476,51,1,0,0,0,477,478,1,0,0,0,478,
        53,1,0,0,0,479,480,1,0,0,0,480,55,1,0,0,0,481,486,3,58,29,0,482,
        483,5,5,0,0,483,485,3,58,29,0,484,482,1,0,0,0,485,488,1,0,0,0,486,
        484,1,0,0,0,486,487,1,0,0,0,487,57,1,0,0,0,488,486,1,0,0,0,489,495,
        3,70,35,0,490,495,3,72,36,0,491,495,3,74,37,0,492,495,3,76,38,0,
        493,495,3,78,39,0,494,489,1,0,0,0,494,490,1,0,0,0,494,491,1,0,0,
        0,494,492,1,0,0,0,494,493,1,0,0,0,495,59,1,0,0,0,496,501,3,62,31,
        0,497,498,5,5,0,0,498,500,3,62,31,0,499,497,1,0,0,0,500,503,1,0,
        0,0,501,499,1,0,0,0,501,502,1,0,0,0,502,61,1,0,0,0,503,501,1,0,0,
        0,504,509,3,66,33,0,505,509,3,126,63,0,506,509,3,96,48,0,507,509,
        3,80,40,0,508,504,1,0,0,0,508,505,1,0,0,0,508,506,1,0,0,0,508,507,
        1,0,0,0,509,63,1,0,0,0,510,512,7,0,0,0,511,513,7,5,0,0,512,511,1,
        0,0,0,512,513,1,0,0,0,513,514,1,0,0,0,514,515,3,22,11,0,515,516,
        5,39,0,0,516,517,3,34,17,0,517,539,1,0,0,0,518,539,3,36,18,0,519,
        520,3,38,19,0,520,521,5,378,0,0,521,525,3,84,42,0,522,523,5,99,0,
        0,523,524,5,259,0,0,524,526,3,56,28,0,525,522,1,0,0,0,525,526,1,
        0,0,0,526,528,1,0,0,0,527,529,3,20,10,0,528,527,1,0,0,0,528,529,
        1,0,0,0,529,536,1,0,0,0,530,531,5,310,0,0,531,532,5,259,0,0,532,
        534,3,60,30,0,533,535,7,1,0,0,534,533,1,0,0,0,534,535,1,0,0,0,535,
        537,1,0,0,0,536,530,1,0,0,0,536,537,1,0,0,0,537,539,1,0,0,0,538,
        510,1,0,0,0,538,518,1,0,0,0,538,519,1,0,0,0,539,65,1,0,0,0,540,541,
        6,33,-1,0,541,595,3,92,46,0,542,595,3,126,63,0,543,544,3,94,47,0,
        544,545,3,66,33,17,545,595,1,0,0,0,546,547,3,120,60,0,547,560,5,
        3,0,0,548,550,5,242,0,0,549,548,1,0,0,0,549,550,1,0,0,0,550,551,
        1,0,0,0,551,556,3,66,33,0,552,553,5,5,0,0,553,555,3,66,33,0,554,
        552,1,0,0,0,555,558,1,0,0,0,556,554,1,0,0,0,556,557,1,0,0,0,557,
        561,1,0,0,0,558,556,1,0,0,0,559,561,5,7,0,0,560,549,1,0,0,0,560,
        559,1,0,0,0,560,561,1,0,0,0,561,562,1,0,0,0,562,563,5,4,0,0,563,
        595,1,0,0,0,564,565,5,3,0,0,565,566,3,66,33,0,566,567,5,4,0,0,567,
        595,1,0,0,0,568,569,5,307,0,0,569,570,5,3,0,0,570,571,3,66,33,0,
        571,572,5,139,0,0,572,573,3,130,65,0,573,574,5,4,0,0,574,595,1,0,
        0,0,575,577,5,289,0,0,576,578,3,66,33,0,577,576,1,0,0,0,577,578,
        1,0,0,0,578,584,1,0,0,0,579,580,5,372,0,0,580,581,3,66,33,0,581,
        582,5,138,0,0,582,583,3,66,33,0,583,585,1,0,0,0,584,579,1,0,0,0,
        585,586,1,0,0,0,586,584,1,0,0,0,586,587,1,0,0,0,587,590,1,0,0,0,
        588,589,5,290,0,0,589,591,3,66,33,0,590,588,1,0,0,0,590,591,1,0,
        0,0,591,592,1,0,0,0,592,593,5,308,0,0,593,595,1,0,0,0,594,540,1,
        0,0,0,594,542,1,0,0,0,594,543,1,0,0,0,594,546,1,0,0,0,594,564,1,
        0,0,0,594,568,1,0,0,0,594,575,1,0,0,0,595,690,1,0,0,0,596,597,10,
        16,0,0,597,598,5,11,0,0,598,689,3,66,33,17,599,600,10,15,0,0,600,
        601,7,6,0,0,601,689,3,66,33,16,602,603,10,14,0,0,603,604,7,7,0,0,
        604,689,3,66,33,15,605,606,10,13,0,0,606,607,7,8,0,0,607,689,3,66,
        33,14,608,618,10,12,0,0,609,619,5,6,0,0,610,619,5,22,0,0,611,619,
        5,23,0,0,612,619,5,24,0,0,613,619,5,285,0,0,614,615,5,285,0,0,615,
        619,5,208,0,0,616,619,5,183,0,0,617,619,5,351,0,0,618,609,1,0,0,
        0,618,610,1,0,0,0,618,611,1,0,0,0,618,612,1,0,0,0,618,613,1,0,0,
        0,618,614,1,0,0,0,618,616,1,0,0,0,618,617,1,0,0,0,619,620,1,0,0,
        0,620,689,3,66,33,13,621,622,10,11,0,0,622,623,5,121,0,0,623,689,
        3,66,33,12,624,625,10,10,0,0,625,626,5,304,0,0,626,689,3,66,33,11,
        627,628,10,4,0,0,628,630,5,285,0,0,629,631,5,208,0,0,630,629,1,0,
        0,0,630,631,1,0,0,0,631,632,1,0,0,0,632,689,3,66,33,5,633,635,10,
        3,0,0,634,636,5,208,0,0,635,634,1,0,0,0,635,636,1,0,0,0,636,637,
        1,0,0,0,637,638,5,229,0,0,638,639,3,66,33,0,639,640,5,121,0,0,640,
        641,3,66,33,4,641,689,1,0,0,0,642,644,10,6,0,0,643,645,5,208,0,0,
        644,643,1,0,0,0,644,645,1,0,0,0,645,646,1,0,0,0,646,647,5,351,0,
        0,647,650,3,66,33,0,648,649,5,338,0,0,649,651,3,66,33,0,650,648,
        1,0,0,0,650,651,1,0,0,0,651,689,1,0,0,0,652,660,10,5,0,0,653,654,
        5,285,0,0,654,661,5,220,0,0,655,656,5,285,0,0,656,657,5,208,0,0,
        657,661,5,220,0,0,658,659,5,208,0,0,659,661,5,220,0,0,660,653,1,
        0,0,0,660,655,1,0,0,0,660,658,1,0,0,0,661,689,1,0,0,0,662,664,10,
        2,0,0,663,665,5,208,0,0,664,663,1,0,0,0,664,665,1,0,0,0,665,666,
        1,0,0,0,666,686,5,183,0,0,667,677,5,3,0,0,668,678,3,10,5,0,669,674,
        3,66,33,0,670,671,5,5,0,0,671,673,3,66,33,0,672,670,1,0,0,0,673,
        676,1,0,0,0,674,672,1,0,0,0,674,675,1,0,0,0,675,678,1,0,0,0,676,
        674,1,0,0,0,677,668,1,0,0,0,677,669,1,0,0,0,677,678,1,0,0,0,678,
        679,1,0,0,0,679,687,5,4,0,0,680,681,3,122,61,0,681,682,5,2,0,0,682,
        684,1,0,0,0,683,680,1,0,0,0,683,684,1,0,0,0,684,685,1,0,0,0,685,
        687,3,124,62,0,686,667,1,0,0,0,686,683,1,0,0,0,687,689,1,0,0,0,688,
        596,1,0,0,0,688,599,1,0,0,0,688,602,1,0,0,0,688,605,1,0,0,0,688,
        608,1,0,0,0,688,621,1,0,0,0,688,624,1,0,0,0,688,627,1,0,0,0,688,
        633,1,0,0,0,688,642,1,0,0,0,688,652,1,0,0,0,688,662,1,0,0,0,689,
        692,1,0,0,0,690,688,1,0,0,0,690,691,1,0,0,0,691,67,1,0,0,0,692,690,
        1,0,0,0,693,698,3,66,33,0,694,695,5,5,0,0,695,697,3,66,33,0,696,
        694,1,0,0,0,697,700,1,0,0,0,698,696,1,0,0,0,698,699,1,0,0,0,699,
        69,1,0,0,0,700,698,1,0,0,0,701,705,3,126,63,0,702,705,3,80,40,0,
        703,705,3,66,33,0,704,701,1,0,0,0,704,702,1,0,0,0,704,703,1,0,0,
        0,705,71,1,0,0,0,706,707,5,3,0,0,707,708,5,4,0,0,708,73,1,0,0,0,
        709,710,1,0,0,0,710,75,1,0,0,0,711,712,1,0,0,0,712,77,1,0,0,0,713,
        714,1,0,0,0,714,79,1,0,0,0,715,716,5,458,0,0,716,81,1,0,0,0,717,
        718,3,10,5,0,718,83,1,0,0,0,719,720,3,66,33,0,720,85,1,0,0,0,721,
        722,3,66,33,0,722,87,1,0,0,0,723,728,3,126,63,0,724,725,5,5,0,0,
        725,727,3,126,63,0,726,724,1,0,0,0,727,730,1,0,0,0,728,726,1,0,0,
        0,728,729,1,0,0,0,729,89,1,0,0,0,730,728,1,0,0,0,731,733,7,7,0,0,
        732,731,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,735,5,457,0,
        0,735,91,1,0,0,0,736,746,5,457,0,0,737,746,5,462,0,0,738,746,5,220,
        0,0,739,746,5,110,0,0,740,746,5,104,0,0,741,746,5,116,0,0,742,746,
        3,108,54,0,743,746,3,112,56,0,744,746,3,110,55,0,745,736,1,0,0,0,
        745,737,1,0,0,0,745,738,1,0,0,0,745,739,1,0,0,0,745,740,1,0,0,0,
        745,741,1,0,0,0,745,742,1,0,0,0,745,743,1,0,0,0,745,744,1,0,0,0,
        746,93,1,0,0,0,747,748,7,9,0,0,748,95,1,0,0,0,749,750,5,461,0,0,
        750,97,1,0,0,0,751,752,5,461,0,0,752,99,1,0,0,0,753,754,5,461,0,
        0,754,101,1,0,0,0,755,756,3,124,62,0,756,103,1,0,0,0,757,758,3,124,
        62,0,758,105,1,0,0,0,759,760,3,124,62,0,760,107,1,0,0,0,761,763,
        5,152,0,0,762,761,1,0,0,0,762,763,1,0,0,0,763,764,1,0,0,0,764,767,
        5,462,0,0,765,767,5,152,0,0,766,762,1,0,0,0,766,765,1,0,0,0,767,
        109,1,0,0,0,768,770,5,156,0,0,769,768,1,0,0,0,769,770,1,0,0,0,770,
        771,1,0,0,0,771,772,5,462,0,0,772,111,1,0,0,0,773,775,5,150,0,0,
        774,773,1,0,0,0,774,775,1,0,0,0,775,776,1,0,0,0,776,777,5,462,0,
        0,777,113,1,0,0,0,778,781,3,110,55,0,779,781,3,108,54,0,780,778,
        1,0,0,0,780,779,1,0,0,0,781,115,1,0,0,0,782,783,7,10,0,0,783,117,
        1,0,0,0,784,785,3,134,67,0,785,119,1,0,0,0,786,789,5,461,0,0,787,
        789,3,116,58,0,788,786,1,0,0,0,788,787,1,0,0,0,789,121,1,0,0,0,790,
        791,5,461,0,0,791,123,1,0,0,0,792,793,3,122,61,0,793,794,5,2,0,0,
        794,796,1,0,0,0,795,792,1,0,0,0,795,796,1,0,0,0,796,797,1,0,0,0,
        797,798,5,461,0,0,798,125,1,0,0,0,799,800,3,124,62,0,800,801,5,2,
        0,0,801,803,1,0,0,0,802,799,1,0,0,0,802,803,1,0,0,0,803,804,1,0,
        0,0,804,805,5,461,0,0,805,127,1,0,0,0,806,807,5,461,0,0,807,129,
        1,0,0,0,808,816,3,132,66,0,809,811,5,3,0,0,810,812,7,11,0,0,811,
        810,1,0,0,0,812,813,1,0,0,0,813,811,1,0,0,0,813,814,1,0,0,0,814,
        815,1,0,0,0,815,817,5,4,0,0,816,809,1,0,0,0,816,817,1,0,0,0,817,
        131,1,0,0,0,818,819,7,12,0,0,819,133,1,0,0,0,820,828,5,461,0,0,821,
        828,3,116,58,0,822,828,5,462,0,0,823,824,5,3,0,0,824,825,3,134,67,
        0,825,826,5,4,0,0,826,828,1,0,0,0,827,820,1,0,0,0,827,821,1,0,0,
        0,827,822,1,0,0,0,827,823,1,0,0,0,828,135,1,0,0,0,104,138,150,154,
        162,171,177,189,192,196,199,202,207,210,216,222,224,228,234,249,
        253,257,261,270,272,277,281,291,299,302,306,309,315,324,331,338,
        346,353,361,363,368,372,375,378,383,385,390,400,406,413,420,425,
        432,439,444,448,451,464,466,486,494,501,508,512,525,528,534,536,
        538,549,556,560,577,586,590,594,618,630,635,644,650,660,664,674,
        677,683,686,688,690,698,704,728,732,745,762,766,769,774,780,788,
        795,802,813,816,827
    ]

class TeradataParser ( Parser ):

    grammarFileName = "Teradata.G4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'.'", "'('", "')'", "','", "'='", 
                     "'*'", "'+'", "'-'", "'~'", "'||'", "'/'", "'%'", "'<<'", 
                     "'>>'", "'&'", "'|'", "'<'", "'<='", "'>'", "'>='", 
                     "'=='", "'!='", "'<>'" ]

    symbolicNames = [ "<INVALID>", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", 
                      "COMMA", "ASSIGN", "STAR", "PLUS", "MINUS", "TILDE", 
                      "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", "PIPE", 
                      "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
                      "K_ABORT", "K_CONVERT_TABLE_HEADER", "K_FOUND", "K_MAX", 
                      "K_QUALIFIED", "K_STATEMENT", "K_ABORTSESSION", "K_CORR", 
                      "K_FREESPACE", "K_MAXIMUM", "K_QUALIFY", "K_STATISTICS", 
                      "K_ABS", "K_COS", "K_FROM", "K_MCHARACTERS", "K_QUANTILE", 
                      "K_STDDEV_POP", "K_ACCESS_LOCK", "K_COSH", "K_FULL", 
                      "K_MDIFF", "K_RADIANS", "K_STDDEV_SAMP", "K_ACCOUNT", 
                      "K_COUNT", "K_FUNCTION", "K_MERGE", "K_RANDOM", "K_STEPINFO", 
                      "K_ACOS", "K_COVAR_POP", "K_GE", "K_MIN", "K_RANGE_N", 
                      "K_STRING_CS", "K_ACOSH", "K_COVAR_SAMP", "K_GENERATED", 
                      "K_MINDEX", "K_RANK", "K_SUBSCRIBER", "K_ADD", "K_CREATE", 
                      "K_GIVE", "K_MINIMUM", "K_REAL", "K_SUBSTR", "K_ADD_MONTHS", 
                      "K_CROSS", "K_GO", "K_MINUS", "K_REFERENCES", "K_SUBSTRING", 
                      "K_ADMIN", "K_CS", "K_GOTO", "K_MINUTE", "K_REFERENCING", 
                      "K_SUM", "K_AFTER", "K_CSUM", "K_GRANT", "K_MLINREG", 
                      "K_REGR_AVGX", "K_SUMMARY", "K_AGGREGATE", "K_CT", 
                      "K_GRAPHIC", "K_MLOAD", "K_REGR_AVGY", "K_SUSPEND", 
                      "K_ALIAS", "K_CURRENT", "K_GROUP", "K_MOD", "K_REGR_COUNT", 
                      "K_TABLE", "K_ALL", "K_CURRENT_DATE", "K_GT", "K_MODE", 
                      "K_REGR_INTERCEPT", "K_TAN", "K_ALTER", "K_CURRENT_TIME", 
                      "K_HANDLER", "K_MODIFY", "K_REGR_R2", "K_TANH", "K_AMP", 
                      "K_CURRENT_TIMESTAMP", "K_HASH", "K_MONITOR", "K_REGR_SLOPE", 
                      "K_TBL_CS", "K_AND", "K_CURSOR", "K_HASHAMP", "K_MONRESOURCE", 
                      "K_REGR_SXX", "K_TEMPORARY", "K_ANSIDATE", "K_CV", 
                      "K_HASHBAKAMP", "K_MONSESSION", "K_REGR_SXY", "K_TERMINATE", 
                      "K_ANY", "K_CYCLE", "K_HASHBUCKET", "K_MONTH", "K_REGR_SYY", 
                      "K_THEN", "K_AS", "K_DATABASE", "K_HASHROW", "K_MSUBSTR", 
                      "K_RELEASE", "K_THRESHOLD", "K_ASC", "K_DATABLOCKSIZE", 
                      "K_HAVING", "K_MSUM", "K_RENAME", "K_TIME", "K_ASIN", 
                      "K_DATE", "K_HELP", "K_MULTISET", "K_REPEAT", "K_TIMESTAMP", 
                      "K_ASINH", "K_DATEFORM", "K_HOUR", "K_NAMED", "K_REPLACE", 
                      "K_TIMEZONE_HOUR", "K_AT", "K_DAY", "K_IDENTITY", 
                      "K_NATURAL", "K_REPLICATION", "K_TIMEZONE_MINUTE", 
                      "K_ATAN", "K_DEC", "K_IF", "K_NE", "K_REPOVERRIDE", 
                      "K_TITLE", "K_ATAN2", "K_DECIMAL", "K_IMMEDIATE", 
                      "K_NEW", "K_REQUEST", "K_TO", "K_ATANH", "K_DECLARE", 
                      "K_IN", "K_NEW_TABLE", "K_RESTART", "K_TRACE", "K_ATOMIC", 
                      "K_DEFAULT", "K_INCONSISTENT", "K_NEXT", "K_RESTORE", 
                      "K_TRAILING", "K_AUTHORIZATION", "K_DEGREES", "K_INDEX", 
                      "K_NO", "K_RESUME", "K_TRANSACTION", "K_AVE", "K_DEL", 
                      "K_INDICATOR", "K_NONE", "K_RET", "K_TRANSLATE", "K_AVERAGE", 
                      "K_DELETE", "K_INITIATE", "K_NOT", "K_RETRIEVE", "K_TRANSLATE_CHK", 
                      "K_AVG", "K_DESC", "K_INNER", "K_NOWAIT", "K_RETURNS", 
                      "K_TRIGGER", "K_BEFORE", "K_DESCRIPTOR", "K_INOUT", 
                      "K_NULL", "K_REVALIDATE", "K_TRIM", "K_BEGIN", "K_DETERMINISTIC", 
                      "K_INPUT", "K_NULLIF", "K_REVOKE", "K_TYPE", "K_BETWEEN", 
                      "K_DIAGNOSTIC", "K_INS", "K_NULLIFZERO", "K_RIGHT", 
                      "K_UC", "K_BLOB", "K_DISABLED", "K_INSERT", "K_NUMERIC", 
                      "K_RIGHTS", "K_UNDEFINED", "K_BOTH", "K_DISTINCT", 
                      "K_INSTEAD", "K_OBJECTS", "K_ROLE", "K_UNDO", "K_BT", 
                      "K_DO", "K_INT", "K_OCTET_LENGTH", "K_ROLLBACK", "K_UNION", 
                      "K_BUT", "K_DOUBLE", "K_INTEGER", "K_OF", "K_ROLLFORWARD", 
                      "K_UNIQUE", "K_BY", "K_DROP", "K_INTEGERDATE", "K_OFF", 
                      "K_ROW", "K_UNTIL", "K_BYTE", "K_DUAL", "K_INTERSECT", 
                      "K_OLD", "K_ROWID", "K_UPD", "K_BYTEINT", "K_DUMP", 
                      "K_INTERVAL", "K_OLD_TABLE", "K_ROWS", "K_UPDATE", 
                      "K_BYTES", "K_EACH", "K_INTO", "K_ON", "K_ROW_NUMBER", 
                      "K_UPPER", "K_CALL", "K_ECHO", "K_IS", "K_ONLY", "K_SAMPLE", 
                      "K_UPPERCASE", "K_CASE", "K_ELSE", "K_ITERATE", "K_OPEN", 
                      "K_SAMPLEID", "K_USER", "K_CASESPECIFIC", "K_ELSEIF", 
                      "K_JOIN", "K_OPTION", "K_SCROLL", "K_USING", "K_CASE_N", 
                      "K_ENABLED", "K_JOURNAL", "K_OR", "K_SECOND", "K_VALUE", 
                      "K_CAST", "K_END", "K_KEY", "K_ORDER", "K_SEL", "K_VALUES", 
                      "K_CD", "K_EQ", "K_KURTOSIS", "K_OUT", "K_SELECT", 
                      "K_VARBYTE", "K_CHAR", "K_ERROR", "K_LANGUAGE", "K_OUTER", 
                      "K_SESSION", "K_VARCHAR", "K_CHAR2HEXINT", "K_ERRORFILES", 
                      "K_LE", "K_OVER", "K_SET", "K_VARGRAPHIC", "K_CHARACTER", 
                      "K_ERRORTABLES", "K_LEADING", "K_OVERLAPS", "K_SETRESRATE", 
                      "K_VARYING", "K_CHARACTERS", "K_ESCAPE", "K_LEAVE", 
                      "K_OVERRIDE", "K_SETSESSRATE", "K_VAR_POP", "K_CHARACTER_LENGTH", 
                      "K_ET", "K_LEFT", "K_PARAMETER", "K_SHOW", "K_VAR_SAMP", 
                      "K_CHARS", "K_EXCEPT", "K_LIKE", "K_PASSWORD", "K_SIMPLE", 
                      "K_VIEW", "K_CHAR_LENGTH", "K_EXEC", "K_LIMIT", "K_PERCENT", 
                      "K_SIN", "K_VOLATILE", "K_CHECK", "K_EXECUTE", "K_LN", 
                      "K_PERCENT_RANK", "K_SINH", "K_WAIT", "K_CHECKPOINT", 
                      "K_EXISTS", "K_LOADING", "K_PERM", "K_SKEW", "K_WHEN", 
                      "K_CLASS", "K_EXIT", "K_LOCAL", "K_PERMANENT", "K_SMALLINT", 
                      "K_WHERE", "K_CLOSE", "K_EXP", "K_LOCATOR", "K_POSITION", 
                      "K_SOME", "K_WHILE", "K_CLUSTER", "K_EXPLAIN", "K_LOCK", 
                      "K_PRECISION", "K_SOUNDEX", "K_WIDTH_BUCKET", "K_CM", 
                      "K_EXTERNAL", "K_LOCKING", "K_PREPARE", "K_SPECIFIC", 
                      "K_WITH", "K_COALESCE", "K_EXTRACT", "K_LOG", "K_PRESERVE", 
                      "K_SPOOL", "K_WITHOUT", "K_COLLATION", "K_FALLBACK", 
                      "K_LOGGING", "K_PRIMARY", "K_SQL", "K_WORK", "K_COLLECT", 
                      "K_FASTEXPORT", "K_LOGON", "K_PRIVATE", "K_SQLEXCEPTION", 
                      "K_YEAR", "K_COLUMN", "K_FETCH", "K_LONG", "K_PRIVILEGES", 
                      "K_SQLTEXT", "K_ZEROIFNULL", "K_COMMENT", "K_FIRST", 
                      "K_LOOP", "K_PROCEDURE", "K_SQLWARNING", "K_ZONE", 
                      "K_COMMIT", "K_FLOAT", "K_LOWER", "K_PROFILE", "K_SQRT", 
                      "K_COMPRESS", "K_FOR", "K_LT", "K_PROPORTIONAL", "K_SS", 
                      "K_CONSTRAINT", "K_FOREIGN", "K_MACRO", "K_PROTECTION", 
                      "K_START", "K_CONTINUE", "K_FORMAT", "K_MAVG", "K_PUBLIC", 
                      "K_STARTUP", "K_TOP", "K_TIES", "K_VALIDTIME", "K_TRANSACTIONTIME", 
                      "K_BIGINT", "K_NORMALIZE", "K_MEETS", "K_LAST", "K_NULLS", 
                      "K_ERRORS", "NUMERIC_LITERAL", "INTEGER", "DECIMAL", 
                      "SCIENTIFIC", "IDENTIFIER", "STRING_LITERAL", "SINGLE_LINE_COMMENT", 
                      "MULTILINE_COMMENT", "SPACES", "UNEXPECTED_CHAR" ]

    RULE_parse = 0
    RULE_error = 1
    RULE_sql_stmt_list = 2
    RULE_sql_stmt = 3
    RULE_select_stmt = 4
    RULE_select_expr = 5
    RULE_insert_stmt = 6
    RULE_insert_sub_expr = 7
    RULE_insert_logging_errors = 8
    RULE_top_expr = 9
    RULE_having_qualify_expr = 10
    RULE_select_list = 11
    RULE_select_list_expr = 12
    RULE_from_clause = 13
    RULE_from_expr = 14
    RULE_as_of = 15
    RULE_from_table_expr = 16
    RULE_from_single_expr = 17
    RULE_from_join_expr = 18
    RULE_from_derived_expr = 19
    RULE_from_tablefunc_expr = 20
    RULE_from_with_expr = 21
    RULE_normalize_expr = 22
    RULE_where_clause = 23
    RULE_having_expr = 24
    RULE_qualify_expr = 25
    RULE_sample_expr = 26
    RULE_expand_expr = 27
    RULE_group_by_list = 28
    RULE_group_by_val = 29
    RULE_order_by_list = 30
    RULE_order_by_val = 31
    RULE_seed_stmt = 32
    RULE_expr = 33
    RULE_expr_list = 34
    RULE_ordinary_grouping_set = 35
    RULE_empty_grouping_set = 36
    RULE_rollup_list = 37
    RULE_cube_list = 38
    RULE_grouping_sets_specification = 39
    RULE_column_position = 40
    RULE_subquery = 41
    RULE_search_condition = 42
    RULE_conditional_expr = 43
    RULE_column_list = 44
    RULE_signed_number = 45
    RULE_literal_value = 46
    RULE_unary_operator = 47
    RULE_column_alias = 48
    RULE_query_name = 49
    RULE_expr_alias_name = 50
    RULE_joined_table = 51
    RULE_single_table_expr = 52
    RULE_derived_table_name = 53
    RULE_date_expr = 54
    RULE_timestamp_expr = 55
    RULE_time_expr = 56
    RULE_date_timestamp_expr = 57
    RULE_keyword = 58
    RULE_name = 59
    RULE_function_name = 60
    RULE_database_name = 61
    RULE_table_name = 62
    RULE_column_name = 63
    RULE_correlation_name = 64
    RULE_type_name = 65
    RULE_types = 66
    RULE_any_name = 67

    ruleNames =  [ "parse", "error", "sql_stmt_list", "sql_stmt", "select_stmt", 
                   "select_expr", "insert_stmt", "insert_sub_expr", "insert_logging_errors", 
                   "top_expr", "having_qualify_expr", "select_list", "select_list_expr", 
                   "from_clause", "from_expr", "as_of", "from_table_expr", 
                   "from_single_expr", "from_join_expr", "from_derived_expr", 
                   "from_tablefunc_expr", "from_with_expr", "normalize_expr", 
                   "where_clause", "having_expr", "qualify_expr", "sample_expr", 
                   "expand_expr", "group_by_list", "group_by_val", "order_by_list", 
                   "order_by_val", "seed_stmt", "expr", "expr_list", "ordinary_grouping_set", 
                   "empty_grouping_set", "rollup_list", "cube_list", "grouping_sets_specification", 
                   "column_position", "subquery", "search_condition", "conditional_expr", 
                   "column_list", "signed_number", "literal_value", "unary_operator", 
                   "column_alias", "query_name", "expr_alias_name", "joined_table", 
                   "single_table_expr", "derived_table_name", "date_expr", 
                   "timestamp_expr", "time_expr", "date_timestamp_expr", 
                   "keyword", "name", "function_name", "database_name", 
                   "table_name", "column_name", "correlation_name", "type_name", 
                   "types", "any_name" ]

    EOF = Token.EOF
    SCOL=1
    DOT=2
    OPEN_PAR=3
    CLOSE_PAR=4
    COMMA=5
    ASSIGN=6
    STAR=7
    PLUS=8
    MINUS=9
    TILDE=10
    PIPE2=11
    DIV=12
    MOD=13
    LT2=14
    GT2=15
    AMP=16
    PIPE=17
    LT=18
    LT_EQ=19
    GT=20
    GT_EQ=21
    EQ=22
    NOT_EQ1=23
    NOT_EQ2=24
    K_ABORT=25
    K_CONVERT_TABLE_HEADER=26
    K_FOUND=27
    K_MAX=28
    K_QUALIFIED=29
    K_STATEMENT=30
    K_ABORTSESSION=31
    K_CORR=32
    K_FREESPACE=33
    K_MAXIMUM=34
    K_QUALIFY=35
    K_STATISTICS=36
    K_ABS=37
    K_COS=38
    K_FROM=39
    K_MCHARACTERS=40
    K_QUANTILE=41
    K_STDDEV_POP=42
    K_ACCESS_LOCK=43
    K_COSH=44
    K_FULL=45
    K_MDIFF=46
    K_RADIANS=47
    K_STDDEV_SAMP=48
    K_ACCOUNT=49
    K_COUNT=50
    K_FUNCTION=51
    K_MERGE=52
    K_RANDOM=53
    K_STEPINFO=54
    K_ACOS=55
    K_COVAR_POP=56
    K_GE=57
    K_MIN=58
    K_RANGE_N=59
    K_STRING_CS=60
    K_ACOSH=61
    K_COVAR_SAMP=62
    K_GENERATED=63
    K_MINDEX=64
    K_RANK=65
    K_SUBSCRIBER=66
    K_ADD=67
    K_CREATE=68
    K_GIVE=69
    K_MINIMUM=70
    K_REAL=71
    K_SUBSTR=72
    K_ADD_MONTHS=73
    K_CROSS=74
    K_GO=75
    K_MINUS=76
    K_REFERENCES=77
    K_SUBSTRING=78
    K_ADMIN=79
    K_CS=80
    K_GOTO=81
    K_MINUTE=82
    K_REFERENCING=83
    K_SUM=84
    K_AFTER=85
    K_CSUM=86
    K_GRANT=87
    K_MLINREG=88
    K_REGR_AVGX=89
    K_SUMMARY=90
    K_AGGREGATE=91
    K_CT=92
    K_GRAPHIC=93
    K_MLOAD=94
    K_REGR_AVGY=95
    K_SUSPEND=96
    K_ALIAS=97
    K_CURRENT=98
    K_GROUP=99
    K_MOD=100
    K_REGR_COUNT=101
    K_TABLE=102
    K_ALL=103
    K_CURRENT_DATE=104
    K_GT=105
    K_MODE=106
    K_REGR_INTERCEPT=107
    K_TAN=108
    K_ALTER=109
    K_CURRENT_TIME=110
    K_HANDLER=111
    K_MODIFY=112
    K_REGR_R2=113
    K_TANH=114
    K_AMP=115
    K_CURRENT_TIMESTAMP=116
    K_HASH=117
    K_MONITOR=118
    K_REGR_SLOPE=119
    K_TBL_CS=120
    K_AND=121
    K_CURSOR=122
    K_HASHAMP=123
    K_MONRESOURCE=124
    K_REGR_SXX=125
    K_TEMPORARY=126
    K_ANSIDATE=127
    K_CV=128
    K_HASHBAKAMP=129
    K_MONSESSION=130
    K_REGR_SXY=131
    K_TERMINATE=132
    K_ANY=133
    K_CYCLE=134
    K_HASHBUCKET=135
    K_MONTH=136
    K_REGR_SYY=137
    K_THEN=138
    K_AS=139
    K_DATABASE=140
    K_HASHROW=141
    K_MSUBSTR=142
    K_RELEASE=143
    K_THRESHOLD=144
    K_ASC=145
    K_DATABLOCKSIZE=146
    K_HAVING=147
    K_MSUM=148
    K_RENAME=149
    K_TIME=150
    K_ASIN=151
    K_DATE=152
    K_HELP=153
    K_MULTISET=154
    K_REPEAT=155
    K_TIMESTAMP=156
    K_ASINH=157
    K_DATEFORM=158
    K_HOUR=159
    K_NAMED=160
    K_REPLACE=161
    K_TIMEZONE_HOUR=162
    K_AT=163
    K_DAY=164
    K_IDENTITY=165
    K_NATURAL=166
    K_REPLICATION=167
    K_TIMEZONE_MINUTE=168
    K_ATAN=169
    K_DEC=170
    K_IF=171
    K_NE=172
    K_REPOVERRIDE=173
    K_TITLE=174
    K_ATAN2=175
    K_DECIMAL=176
    K_IMMEDIATE=177
    K_NEW=178
    K_REQUEST=179
    K_TO=180
    K_ATANH=181
    K_DECLARE=182
    K_IN=183
    K_NEW_TABLE=184
    K_RESTART=185
    K_TRACE=186
    K_ATOMIC=187
    K_DEFAULT=188
    K_INCONSISTENT=189
    K_NEXT=190
    K_RESTORE=191
    K_TRAILING=192
    K_AUTHORIZATION=193
    K_DEGREES=194
    K_INDEX=195
    K_NO=196
    K_RESUME=197
    K_TRANSACTION=198
    K_AVE=199
    K_DEL=200
    K_INDICATOR=201
    K_NONE=202
    K_RET=203
    K_TRANSLATE=204
    K_AVERAGE=205
    K_DELETE=206
    K_INITIATE=207
    K_NOT=208
    K_RETRIEVE=209
    K_TRANSLATE_CHK=210
    K_AVG=211
    K_DESC=212
    K_INNER=213
    K_NOWAIT=214
    K_RETURNS=215
    K_TRIGGER=216
    K_BEFORE=217
    K_DESCRIPTOR=218
    K_INOUT=219
    K_NULL=220
    K_REVALIDATE=221
    K_TRIM=222
    K_BEGIN=223
    K_DETERMINISTIC=224
    K_INPUT=225
    K_NULLIF=226
    K_REVOKE=227
    K_TYPE=228
    K_BETWEEN=229
    K_DIAGNOSTIC=230
    K_INS=231
    K_NULLIFZERO=232
    K_RIGHT=233
    K_UC=234
    K_BLOB=235
    K_DISABLED=236
    K_INSERT=237
    K_NUMERIC=238
    K_RIGHTS=239
    K_UNDEFINED=240
    K_BOTH=241
    K_DISTINCT=242
    K_INSTEAD=243
    K_OBJECTS=244
    K_ROLE=245
    K_UNDO=246
    K_BT=247
    K_DO=248
    K_INT=249
    K_OCTET_LENGTH=250
    K_ROLLBACK=251
    K_UNION=252
    K_BUT=253
    K_DOUBLE=254
    K_INTEGER=255
    K_OF=256
    K_ROLLFORWARD=257
    K_UNIQUE=258
    K_BY=259
    K_DROP=260
    K_INTEGERDATE=261
    K_OFF=262
    K_ROW=263
    K_UNTIL=264
    K_BYTE=265
    K_DUAL=266
    K_INTERSECT=267
    K_OLD=268
    K_ROWID=269
    K_UPD=270
    K_BYTEINT=271
    K_DUMP=272
    K_INTERVAL=273
    K_OLD_TABLE=274
    K_ROWS=275
    K_UPDATE=276
    K_BYTES=277
    K_EACH=278
    K_INTO=279
    K_ON=280
    K_ROW_NUMBER=281
    K_UPPER=282
    K_CALL=283
    K_ECHO=284
    K_IS=285
    K_ONLY=286
    K_SAMPLE=287
    K_UPPERCASE=288
    K_CASE=289
    K_ELSE=290
    K_ITERATE=291
    K_OPEN=292
    K_SAMPLEID=293
    K_USER=294
    K_CASESPECIFIC=295
    K_ELSEIF=296
    K_JOIN=297
    K_OPTION=298
    K_SCROLL=299
    K_USING=300
    K_CASE_N=301
    K_ENABLED=302
    K_JOURNAL=303
    K_OR=304
    K_SECOND=305
    K_VALUE=306
    K_CAST=307
    K_END=308
    K_KEY=309
    K_ORDER=310
    K_SEL=311
    K_VALUES=312
    K_CD=313
    K_EQ=314
    K_KURTOSIS=315
    K_OUT=316
    K_SELECT=317
    K_VARBYTE=318
    K_CHAR=319
    K_ERROR=320
    K_LANGUAGE=321
    K_OUTER=322
    K_SESSION=323
    K_VARCHAR=324
    K_CHAR2HEXINT=325
    K_ERRORFILES=326
    K_LE=327
    K_OVER=328
    K_SET=329
    K_VARGRAPHIC=330
    K_CHARACTER=331
    K_ERRORTABLES=332
    K_LEADING=333
    K_OVERLAPS=334
    K_SETRESRATE=335
    K_VARYING=336
    K_CHARACTERS=337
    K_ESCAPE=338
    K_LEAVE=339
    K_OVERRIDE=340
    K_SETSESSRATE=341
    K_VAR_POP=342
    K_CHARACTER_LENGTH=343
    K_ET=344
    K_LEFT=345
    K_PARAMETER=346
    K_SHOW=347
    K_VAR_SAMP=348
    K_CHARS=349
    K_EXCEPT=350
    K_LIKE=351
    K_PASSWORD=352
    K_SIMPLE=353
    K_VIEW=354
    K_CHAR_LENGTH=355
    K_EXEC=356
    K_LIMIT=357
    K_PERCENT=358
    K_SIN=359
    K_VOLATILE=360
    K_CHECK=361
    K_EXECUTE=362
    K_LN=363
    K_PERCENT_RANK=364
    K_SINH=365
    K_WAIT=366
    K_CHECKPOINT=367
    K_EXISTS=368
    K_LOADING=369
    K_PERM=370
    K_SKEW=371
    K_WHEN=372
    K_CLASS=373
    K_EXIT=374
    K_LOCAL=375
    K_PERMANENT=376
    K_SMALLINT=377
    K_WHERE=378
    K_CLOSE=379
    K_EXP=380
    K_LOCATOR=381
    K_POSITION=382
    K_SOME=383
    K_WHILE=384
    K_CLUSTER=385
    K_EXPLAIN=386
    K_LOCK=387
    K_PRECISION=388
    K_SOUNDEX=389
    K_WIDTH_BUCKET=390
    K_CM=391
    K_EXTERNAL=392
    K_LOCKING=393
    K_PREPARE=394
    K_SPECIFIC=395
    K_WITH=396
    K_COALESCE=397
    K_EXTRACT=398
    K_LOG=399
    K_PRESERVE=400
    K_SPOOL=401
    K_WITHOUT=402
    K_COLLATION=403
    K_FALLBACK=404
    K_LOGGING=405
    K_PRIMARY=406
    K_SQL=407
    K_WORK=408
    K_COLLECT=409
    K_FASTEXPORT=410
    K_LOGON=411
    K_PRIVATE=412
    K_SQLEXCEPTION=413
    K_YEAR=414
    K_COLUMN=415
    K_FETCH=416
    K_LONG=417
    K_PRIVILEGES=418
    K_SQLTEXT=419
    K_ZEROIFNULL=420
    K_COMMENT=421
    K_FIRST=422
    K_LOOP=423
    K_PROCEDURE=424
    K_SQLWARNING=425
    K_ZONE=426
    K_COMMIT=427
    K_FLOAT=428
    K_LOWER=429
    K_PROFILE=430
    K_SQRT=431
    K_COMPRESS=432
    K_FOR=433
    K_LT=434
    K_PROPORTIONAL=435
    K_SS=436
    K_CONSTRAINT=437
    K_FOREIGN=438
    K_MACRO=439
    K_PROTECTION=440
    K_START=441
    K_CONTINUE=442
    K_FORMAT=443
    K_MAVG=444
    K_PUBLIC=445
    K_STARTUP=446
    K_TOP=447
    K_TIES=448
    K_VALIDTIME=449
    K_TRANSACTIONTIME=450
    K_BIGINT=451
    K_NORMALIZE=452
    K_MEETS=453
    K_LAST=454
    K_NULLS=455
    K_ERRORS=456
    NUMERIC_LITERAL=457
    INTEGER=458
    DECIMAL=459
    SCIENTIFIC=460
    IDENTIFIER=461
    STRING_LITERAL=462
    SINGLE_LINE_COMMENT=463
    MULTILINE_COMMENT=464
    SPACES=465
    UNEXPECTED_CHAR=466

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ParseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(TeradataParser.EOF, 0)

        def sql_stmt_list(self):
            return self.getTypedRuleContext(TeradataParser.Sql_stmt_listContext,0)


        def error(self):
            return self.getTypedRuleContext(TeradataParser.ErrorContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_parse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParse" ):
                listener.enterParse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParse" ):
                listener.exitParse(self)




    def parse(self):

        localctx = TeradataParser.ParseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_parse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [231, 237, 311, 317, 396]:
                self.state = 136
                self.sql_stmt_list()
                pass
            elif token in [466]:
                self.state = 137
                self.error()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 140
            self.match(TeradataParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._UNEXPECTED_CHAR = None # Token

        def UNEXPECTED_CHAR(self):
            return self.getToken(TeradataParser.UNEXPECTED_CHAR, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_error

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterError" ):
                listener.enterError(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitError" ):
                listener.exitError(self)




    def error(self):

        localctx = TeradataParser.ErrorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_error)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            localctx._UNEXPECTED_CHAR = self.match(TeradataParser.UNEXPECTED_CHAR)
            raise RuntimeException("UNEXPECTED_CHAR=" + (None if localctx._UNEXPECTED_CHAR is None else localctx._UNEXPECTED_CHAR.text));
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_stmt_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sql_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Sql_stmtContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Sql_stmtContext,i)


        def SCOL(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.SCOL)
            else:
                return self.getToken(TeradataParser.SCOL, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_sql_stmt_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSql_stmt_list" ):
                listener.enterSql_stmt_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSql_stmt_list" ):
                listener.exitSql_stmt_list(self)




    def sql_stmt_list(self):

        localctx = TeradataParser.Sql_stmt_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sql_stmt_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 145
                self.sql_stmt()
                self.state = 146
                self.match(TeradataParser.SCOL)
                self.state = 150 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==231 or _la==237 or _la==311 or _la==317 or _la==396):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(TeradataParser.Select_stmtContext,0)


        def insert_stmt(self):
            return self.getTypedRuleContext(TeradataParser.Insert_stmtContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_sql_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSql_stmt" ):
                listener.enterSql_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSql_stmt" ):
                listener.exitSql_stmt(self)




    def sql_stmt(self):

        localctx = TeradataParser.Sql_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_sql_stmt)
        try:
            self.state = 154
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [311, 317, 396]:
                self.enterOuterAlt(localctx, 1)
                self.state = 152
                self.select_stmt()
                pass
            elif token in [231, 237]:
                self.enterOuterAlt(localctx, 2)
                self.state = 153
                self.insert_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WITH(self):
            return self.getToken(TeradataParser.K_WITH, 0)

        def query_name(self):
            return self.getTypedRuleContext(TeradataParser.Query_nameContext,0)


        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.OPEN_PAR)
            else:
                return self.getToken(TeradataParser.OPEN_PAR, i)

        def select_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Select_exprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Select_exprContext,i)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.CLOSE_PAR)
            else:
                return self.getToken(TeradataParser.CLOSE_PAR, i)

        def column_list(self):
            return self.getTypedRuleContext(TeradataParser.Column_listContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_stmt" ):
                listener.enterSelect_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_stmt" ):
                listener.exitSelect_stmt(self)




    def select_stmt(self):

        localctx = TeradataParser.Select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_select_stmt)
        self._la = 0 # Token type
        try:
            self.state = 171
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [396]:
                self.enterOuterAlt(localctx, 1)
                self.state = 156
                self.match(TeradataParser.K_WITH)
                self.state = 157
                self.query_name()
                self.state = 162
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==3:
                    self.state = 158
                    self.match(TeradataParser.OPEN_PAR)
                    self.state = 159
                    self.column_list()
                    self.state = 160
                    self.match(TeradataParser.CLOSE_PAR)


                self.state = 164
                self.match(TeradataParser.K_AS)
                self.state = 165
                self.match(TeradataParser.OPEN_PAR)
                self.state = 166
                self.select_expr()
                self.state = 167
                self.match(TeradataParser.CLOSE_PAR)
                self.state = 168
                self.select_expr()
                pass
            elif token in [311, 317]:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.select_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_list(self):
            return self.getTypedRuleContext(TeradataParser.Select_listContext,0)


        def K_SELECT(self):
            return self.getToken(TeradataParser.K_SELECT, 0)

        def K_SEL(self):
            return self.getToken(TeradataParser.K_SEL, 0)

        def top_expr(self):
            return self.getTypedRuleContext(TeradataParser.Top_exprContext,0)


        def from_clause(self):
            return self.getTypedRuleContext(TeradataParser.From_clauseContext,0)


        def from_with_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_with_exprContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(TeradataParser.Where_clauseContext,0)


        def K_GROUP(self):
            return self.getToken(TeradataParser.K_GROUP, 0)

        def K_BY(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_BY)
            else:
                return self.getToken(TeradataParser.K_BY, i)

        def group_by_list(self):
            return self.getTypedRuleContext(TeradataParser.Group_by_listContext,0)


        def having_qualify_expr(self):
            return self.getTypedRuleContext(TeradataParser.Having_qualify_exprContext,0)


        def K_ORDER(self):
            return self.getToken(TeradataParser.K_ORDER, 0)

        def order_by_list(self):
            return self.getTypedRuleContext(TeradataParser.Order_by_listContext,0)


        def K_NULLS(self):
            return self.getToken(TeradataParser.K_NULLS, 0)

        def K_FIRST(self):
            return self.getToken(TeradataParser.K_FIRST, 0)

        def K_LAST(self):
            return self.getToken(TeradataParser.K_LAST, 0)

        def K_DISTINCT(self):
            return self.getToken(TeradataParser.K_DISTINCT, 0)

        def K_ALL(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_ALL)
            else:
                return self.getToken(TeradataParser.K_ALL, i)

        def normalize_expr(self):
            return self.getTypedRuleContext(TeradataParser.Normalize_exprContext,0)


        def K_ASC(self):
            return self.getToken(TeradataParser.K_ASC, 0)

        def K_DESC(self):
            return self.getToken(TeradataParser.K_DESC, 0)

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.DOT)
            else:
                return self.getToken(TeradataParser.DOT, i)

        def STAR(self):
            return self.getToken(TeradataParser.STAR, 0)

        def column_name(self):
            return self.getTypedRuleContext(TeradataParser.Column_nameContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_select_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_expr" ):
                listener.enterSelect_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_expr" ):
                listener.exitSelect_expr(self)




    def select_expr(self):

        localctx = TeradataParser.Select_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_select_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            _la = self._input.LA(1)
            if not(_la==311 or _la==317):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 177
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [242]:
                    self.state = 174
                    self.match(TeradataParser.K_DISTINCT)
                    pass
                elif token in [103]:
                    self.state = 175
                    self.match(TeradataParser.K_ALL)
                    pass
                elif token in [452]:
                    self.state = 176
                    self.normalize_expr()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 189
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 179
                    self.table_name()
                    self.state = 180
                    self.match(TeradataParser.DOT)
                    self.state = 181
                    self.match(TeradataParser.STAR)
                    self.state = 182
                    self.match(TeradataParser.DOT)
                    self.state = 183
                    self.match(TeradataParser.K_ALL)

                elif la_ == 2:
                    self.state = 185
                    self.column_name()
                    self.state = 186
                    self.match(TeradataParser.DOT)
                    self.state = 187
                    self.match(TeradataParser.K_ALL)



            elif la_ == 2:
                self.state = 191
                self.top_expr()


            self.state = 194
            self.select_list()
            self.state = 196
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 195
                self.from_clause()


            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==396:
                self.state = 198
                self.from_with_expr()


            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==378:
                self.state = 201
                self.where_clause()


            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==99:
                self.state = 204
                self.match(TeradataParser.K_GROUP)
                self.state = 205
                self.match(TeradataParser.K_BY)
                self.state = 206
                self.group_by_list()


            self.state = 210
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35 or _la==147:
                self.state = 209
                self.having_qualify_expr()


            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==310:
                self.state = 212
                self.match(TeradataParser.K_ORDER)
                self.state = 213
                self.match(TeradataParser.K_BY)
                self.state = 214
                self.order_by_list()
                self.state = 216
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==145 or _la==212:
                    self.state = 215
                    _la = self._input.LA(1)
                    if not(_la==145 or _la==212):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 222
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                if la_ == 1:
                    self.state = 218
                    self.match(TeradataParser.K_NULLS)
                    self.state = 219
                    self.match(TeradataParser.K_FIRST)

                elif la_ == 2:
                    self.state = 220
                    self.match(TeradataParser.K_NULLS)
                    self.state = 221
                    self.match(TeradataParser.K_LAST)




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def insert_sub_expr(self):
            return self.getTypedRuleContext(TeradataParser.Insert_sub_exprContext,0)


        def K_INSERT(self):
            return self.getToken(TeradataParser.K_INSERT, 0)

        def K_INS(self):
            return self.getToken(TeradataParser.K_INS, 0)

        def K_INTO(self):
            return self.getToken(TeradataParser.K_INTO, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_insert_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_stmt" ):
                listener.enterInsert_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_stmt" ):
                listener.exitInsert_stmt(self)




    def insert_stmt(self):

        localctx = TeradataParser.Insert_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_insert_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            _la = self._input.LA(1)
            if not(_la==231 or _la==237):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==279:
                self.state = 227
                self.match(TeradataParser.K_INTO)


            self.state = 230
            self.table_name()
            self.state = 231
            self.insert_sub_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_sub_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.OPEN_PAR)
            else:
                return self.getToken(TeradataParser.OPEN_PAR, i)

        def expr_list(self):
            return self.getTypedRuleContext(TeradataParser.Expr_listContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.CLOSE_PAR)
            else:
                return self.getToken(TeradataParser.CLOSE_PAR, i)

        def K_VALUES(self):
            return self.getToken(TeradataParser.K_VALUES, 0)

        def column_list(self):
            return self.getTypedRuleContext(TeradataParser.Column_listContext,0)


        def subquery(self):
            return self.getTypedRuleContext(TeradataParser.SubqueryContext,0)


        def insert_logging_errors(self):
            return self.getTypedRuleContext(TeradataParser.Insert_logging_errorsContext,0)


        def K_DEFAULT(self):
            return self.getToken(TeradataParser.K_DEFAULT, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_insert_sub_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_sub_expr" ):
                listener.enterInsert_sub_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_sub_expr" ):
                listener.exitInsert_sub_expr(self)




    def insert_sub_expr(self):

        localctx = TeradataParser.Insert_sub_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_insert_sub_expr)
        self._la = 0 # Token type
        try:
            self.state = 257
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==312:
                    self.state = 233
                    self.match(TeradataParser.K_VALUES)


                self.state = 236
                self.match(TeradataParser.OPEN_PAR)
                self.state = 237
                self.expr_list()
                self.state = 238
                self.match(TeradataParser.CLOSE_PAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 240
                self.match(TeradataParser.OPEN_PAR)
                self.state = 241
                self.column_list()
                self.state = 242
                self.match(TeradataParser.CLOSE_PAR)
                self.state = 243
                self.match(TeradataParser.K_VALUES)
                self.state = 244
                self.match(TeradataParser.OPEN_PAR)
                self.state = 245
                self.expr_list()
                self.state = 246
                self.match(TeradataParser.CLOSE_PAR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==461:
                    self.state = 248
                    self.column_list()


                self.state = 251
                self.subquery()
                self.state = 253
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==405:
                    self.state = 252
                    self.insert_logging_errors()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 255
                self.match(TeradataParser.K_DEFAULT)
                self.state = 256
                self.match(TeradataParser.K_VALUES)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_logging_errorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LOGGING(self):
            return self.getToken(TeradataParser.K_LOGGING, 0)

        def K_ERRORS(self):
            return self.getToken(TeradataParser.K_ERRORS, 0)

        def K_ALL(self):
            return self.getToken(TeradataParser.K_ALL, 0)

        def K_WITH(self):
            return self.getToken(TeradataParser.K_WITH, 0)

        def K_NO(self):
            return self.getToken(TeradataParser.K_NO, 0)

        def K_LIMIT(self):
            return self.getToken(TeradataParser.K_LIMIT, 0)

        def K_OF(self):
            return self.getToken(TeradataParser.K_OF, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(TeradataParser.NUMERIC_LITERAL, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_insert_logging_errors

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_logging_errors" ):
                listener.enterInsert_logging_errors(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_logging_errors" ):
                listener.exitInsert_logging_errors(self)




    def insert_logging_errors(self):

        localctx = TeradataParser.Insert_logging_errorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_insert_logging_errors)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(TeradataParser.K_LOGGING)
            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 260
                self.match(TeradataParser.K_ALL)


            self.state = 263
            self.match(TeradataParser.K_ERRORS)
            self.state = 272
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==396:
                self.state = 264
                self.match(TeradataParser.K_WITH)
                self.state = 270
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [196]:
                    self.state = 265
                    self.match(TeradataParser.K_NO)
                    self.state = 266
                    self.match(TeradataParser.K_LIMIT)
                    pass
                elif token in [357]:
                    self.state = 267
                    self.match(TeradataParser.K_LIMIT)
                    self.state = 268
                    self.match(TeradataParser.K_OF)
                    self.state = 269
                    self.match(TeradataParser.NUMERIC_LITERAL)
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Top_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TOP(self):
            return self.getToken(TeradataParser.K_TOP, 0)

        def INTEGER(self):
            return self.getToken(TeradataParser.INTEGER, 0)

        def DECIMAL(self):
            return self.getToken(TeradataParser.DECIMAL, 0)

        def K_PERCENT(self):
            return self.getToken(TeradataParser.K_PERCENT, 0)

        def K_WITH(self):
            return self.getToken(TeradataParser.K_WITH, 0)

        def K_TIES(self):
            return self.getToken(TeradataParser.K_TIES, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_top_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTop_expr" ):
                listener.enterTop_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTop_expr" ):
                listener.exitTop_expr(self)




    def top_expr(self):

        localctx = TeradataParser.Top_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_top_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(TeradataParser.K_TOP)
            self.state = 275
            _la = self._input.LA(1)
            if not(_la==458 or _la==459):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 277
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 276
                self.match(TeradataParser.K_PERCENT)


            self.state = 281
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 279
                self.match(TeradataParser.K_WITH)
                self.state = 280
                self.match(TeradataParser.K_TIES)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Having_qualify_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def having_expr(self):
            return self.getTypedRuleContext(TeradataParser.Having_exprContext,0)


        def qualify_expr(self):
            return self.getTypedRuleContext(TeradataParser.Qualify_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_having_qualify_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHaving_qualify_expr" ):
                listener.enterHaving_qualify_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHaving_qualify_expr" ):
                listener.exitHaving_qualify_expr(self)




    def having_qualify_expr(self):

        localctx = TeradataParser.Having_qualify_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_having_qualify_expr)
        try:
            self.state = 291
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 283
                self.having_expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 284
                self.qualify_expr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 285
                self.having_expr()
                self.state = 286
                self.qualify_expr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 288
                self.qualify_expr()
                self.state = 289
                self.having_expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(TeradataParser.STAR, 0)

        def select_list_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Select_list_exprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Select_list_exprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_select_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_list" ):
                listener.enterSelect_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_list" ):
                listener.exitSelect_list(self)




    def select_list(self):

        localctx = TeradataParser.Select_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_select_list)
        self._la = 0 # Token type
        try:
            self.state = 302
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 293
                self.match(TeradataParser.STAR)
                pass
            elif token in [3, 8, 9, 10, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 457, 461, 462]:
                self.enterOuterAlt(localctx, 2)
                self.state = 294
                self.select_list_expr()
                self.state = 299
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 295
                    self.match(TeradataParser.COMMA)
                    self.state = 296
                    self.select_list_expr()
                    self.state = 301
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_list_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def DOT(self):
            return self.getToken(TeradataParser.DOT, 0)

        def STAR(self):
            return self.getToken(TeradataParser.STAR, 0)

        def expr(self):
            return self.getTypedRuleContext(TeradataParser.ExprContext,0)


        def expr_alias_name(self):
            return self.getTypedRuleContext(TeradataParser.Expr_alias_nameContext,0)


        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_select_list_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_list_expr" ):
                listener.enterSelect_list_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_list_expr" ):
                listener.exitSelect_list_expr(self)




    def select_list_expr(self):

        localctx = TeradataParser.Select_list_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_select_list_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 304
                self.expr(0)
                self.state = 309
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==139 or _la==461:
                    self.state = 306
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==139:
                        self.state = 305
                        self.match(TeradataParser.K_AS)


                    self.state = 308
                    self.expr_alias_name()


                pass

            elif la_ == 2:
                self.state = 311
                self.table_name()
                self.state = 312
                self.match(TeradataParser.DOT)
                self.state = 313
                self.match(TeradataParser.STAR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FROM(self):
            return self.getToken(TeradataParser.K_FROM, 0)

        def from_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_from_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_clause" ):
                listener.enterFrom_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_clause" ):
                listener.exitFrom_clause(self)




    def from_clause(self):

        localctx = TeradataParser.From_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_from_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            self.match(TeradataParser.K_FROM)
            self.state = 318
            self.from_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_table_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_table_exprContext,0)


        def from_join_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.From_join_exprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.From_join_exprContext,i)


        def getRuleIndex(self):
            return TeradataParser.RULE_from_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_expr" ):
                listener.enterFrom_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_expr" ):
                listener.exitFrom_expr(self)




    def from_expr(self):

        localctx = TeradataParser.From_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_from_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.from_table_expr()
            self.state = 324
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5 or _la==45 or _la==74 or _la==213 or _la==233 or _la==345:
                self.state = 321
                self.from_join_expr()
                self.state = 326
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class As_ofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_AS(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_AS)
            else:
                return self.getToken(TeradataParser.K_AS, i)

        def K_OF(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_OF)
            else:
                return self.getToken(TeradataParser.K_OF, i)

        def date_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Date_exprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Date_exprContext,i)


        def timestamp_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Timestamp_exprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Timestamp_exprContext,i)


        def K_VALIDTIME(self):
            return self.getToken(TeradataParser.K_VALIDTIME, 0)

        def K_AND(self):
            return self.getToken(TeradataParser.K_AND, 0)

        def K_TRANSACTIONTIME(self):
            return self.getToken(TeradataParser.K_TRANSACTIONTIME, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_as_of

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAs_of" ):
                listener.enterAs_of(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAs_of" ):
                listener.exitAs_of(self)




    def as_of(self):

        localctx = TeradataParser.As_ofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_as_of)
        try:
            self.state = 363
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [139]:
                self.enterOuterAlt(localctx, 1)
                self.state = 327
                self.match(TeradataParser.K_AS)
                self.state = 328
                self.match(TeradataParser.K_OF)
                self.state = 331
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
                if la_ == 1:
                    self.state = 329
                    self.date_expr()

                elif la_ == 2:
                    self.state = 330
                    self.timestamp_expr()


                pass
            elif token in [449]:
                self.enterOuterAlt(localctx, 2)
                self.state = 333
                self.match(TeradataParser.K_VALIDTIME)
                self.state = 334
                self.match(TeradataParser.K_AS)
                self.state = 335
                self.match(TeradataParser.K_OF)
                self.state = 338
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                if la_ == 1:
                    self.state = 336
                    self.date_expr()

                elif la_ == 2:
                    self.state = 337
                    self.timestamp_expr()


                self.state = 340
                self.match(TeradataParser.K_AND)
                self.state = 341
                self.match(TeradataParser.K_TRANSACTIONTIME)
                self.state = 342
                self.match(TeradataParser.K_AS)
                self.state = 343
                self.match(TeradataParser.K_OF)
                self.state = 346
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
                if la_ == 1:
                    self.state = 344
                    self.date_expr()

                elif la_ == 2:
                    self.state = 345
                    self.timestamp_expr()


                pass
            elif token in [450]:
                self.enterOuterAlt(localctx, 3)
                self.state = 348
                self.match(TeradataParser.K_TRANSACTIONTIME)
                self.state = 349
                self.match(TeradataParser.K_AS)
                self.state = 350
                self.match(TeradataParser.K_OF)
                self.state = 353
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 351
                    self.date_expr()

                elif la_ == 2:
                    self.state = 352
                    self.timestamp_expr()


                self.state = 355
                self.match(TeradataParser.K_AND)
                self.state = 356
                self.match(TeradataParser.K_VALIDTIME)
                self.state = 357
                self.match(TeradataParser.K_AS)
                self.state = 358
                self.match(TeradataParser.K_OF)
                self.state = 361
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
                if la_ == 1:
                    self.state = 359
                    self.date_expr()

                elif la_ == 2:
                    self.state = 360
                    self.timestamp_expr()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_table_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_single_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_single_exprContext,0)


        def from_derived_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_derived_exprContext,0)


        def from_tablefunc_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_tablefunc_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_from_table_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_table_expr" ):
                listener.enterFrom_table_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_table_expr" ):
                listener.exitFrom_table_expr(self)




    def from_table_expr(self):

        localctx = TeradataParser.From_table_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_from_table_expr)
        try:
            self.state = 368
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [461]:
                self.enterOuterAlt(localctx, 1)
                self.state = 365
                self.from_single_expr()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 366
                self.from_derived_expr()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 3)
                self.state = 367
                self.from_tablefunc_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_single_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def as_of(self):
            return self.getTypedRuleContext(TeradataParser.As_ofContext,0)


        def correlation_name(self):
            return self.getTypedRuleContext(TeradataParser.Correlation_nameContext,0)


        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_from_single_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_single_expr" ):
                listener.enterFrom_single_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_single_expr" ):
                listener.exitFrom_single_expr(self)




    def from_single_expr(self):

        localctx = TeradataParser.From_single_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_from_single_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 370
            self.table_name()
            self.state = 372
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.state = 371
                self.as_of()


            self.state = 378
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.state = 375
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==139:
                    self.state = 374
                    self.match(TeradataParser.K_AS)


                self.state = 377
                self.correlation_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_join_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_JOIN(self):
            return self.getToken(TeradataParser.K_JOIN, 0)

        def from_table_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_table_exprContext,0)


        def K_ON(self):
            return self.getToken(TeradataParser.K_ON, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TeradataParser.Search_conditionContext,0)


        def K_INNER(self):
            return self.getToken(TeradataParser.K_INNER, 0)

        def K_LEFT(self):
            return self.getToken(TeradataParser.K_LEFT, 0)

        def K_RIGHT(self):
            return self.getToken(TeradataParser.K_RIGHT, 0)

        def K_FULL(self):
            return self.getToken(TeradataParser.K_FULL, 0)

        def as_of(self):
            return self.getTypedRuleContext(TeradataParser.As_ofContext,0)


        def K_OUTER(self):
            return self.getToken(TeradataParser.K_OUTER, 0)

        def K_CROSS(self):
            return self.getToken(TeradataParser.K_CROSS, 0)

        def COMMA(self):
            return self.getToken(TeradataParser.COMMA, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_from_join_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_join_expr" ):
                listener.enterFrom_join_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_join_expr" ):
                listener.exitFrom_join_expr(self)




    def from_join_expr(self):

        localctx = TeradataParser.From_join_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_from_join_expr)
        self._la = 0 # Token type
        try:
            self.state = 400
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [45, 213, 233, 345]:
                self.enterOuterAlt(localctx, 1)
                self.state = 385
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [213]:
                    self.state = 380
                    self.match(TeradataParser.K_INNER)
                    pass
                elif token in [45, 233, 345]:
                    self.state = 381
                    _la = self._input.LA(1)
                    if not(_la==45 or _la==233 or _la==345):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 383
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==322:
                        self.state = 382
                        self.match(TeradataParser.K_OUTER)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 387
                self.match(TeradataParser.K_JOIN)
                self.state = 388
                self.from_table_expr()
                self.state = 390
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==139 or _la==449 or _la==450:
                    self.state = 389
                    self.as_of()


                self.state = 392
                self.match(TeradataParser.K_ON)
                self.state = 393
                self.search_condition()
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self.match(TeradataParser.K_CROSS)
                self.state = 396
                self.match(TeradataParser.K_JOIN)
                self.state = 397
                self.from_table_expr()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 3)
                self.state = 398
                self.match(TeradataParser.COMMA)
                self.state = 399
                self.from_table_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_derived_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.OPEN_PAR)
            else:
                return self.getToken(TeradataParser.OPEN_PAR, i)

        def subquery(self):
            return self.getTypedRuleContext(TeradataParser.SubqueryContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.CLOSE_PAR)
            else:
                return self.getToken(TeradataParser.CLOSE_PAR, i)

        def derived_table_name(self):
            return self.getTypedRuleContext(TeradataParser.Derived_table_nameContext,0)


        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def column_list(self):
            return self.getTypedRuleContext(TeradataParser.Column_listContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_from_derived_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_derived_expr" ):
                listener.enterFrom_derived_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_derived_expr" ):
                listener.exitFrom_derived_expr(self)




    def from_derived_expr(self):

        localctx = TeradataParser.From_derived_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_from_derived_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.match(TeradataParser.OPEN_PAR)
            self.state = 403
            self.subquery()
            self.state = 404
            self.match(TeradataParser.CLOSE_PAR)
            self.state = 406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==139:
                self.state = 405
                self.match(TeradataParser.K_AS)


            self.state = 408
            self.derived_table_name()
            self.state = 413
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 409
                self.match(TeradataParser.OPEN_PAR)
                self.state = 410
                self.column_list()
                self.state = 411
                self.match(TeradataParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_tablefunc_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TABLE(self):
            return self.getToken(TeradataParser.K_TABLE, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.OPEN_PAR)
            else:
                return self.getToken(TeradataParser.OPEN_PAR, i)

        def function_name(self):
            return self.getTypedRuleContext(TeradataParser.Function_nameContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.CLOSE_PAR)
            else:
                return self.getToken(TeradataParser.CLOSE_PAR, i)

        def derived_table_name(self):
            return self.getTypedRuleContext(TeradataParser.Derived_table_nameContext,0)


        def expr_list(self):
            return self.getTypedRuleContext(TeradataParser.Expr_listContext,0)


        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def column_list(self):
            return self.getTypedRuleContext(TeradataParser.Column_listContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_from_tablefunc_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_tablefunc_expr" ):
                listener.enterFrom_tablefunc_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_tablefunc_expr" ):
                listener.exitFrom_tablefunc_expr(self)




    def from_tablefunc_expr(self):

        localctx = TeradataParser.From_tablefunc_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_from_tablefunc_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            self.match(TeradataParser.K_TABLE)
            self.state = 416
            self.match(TeradataParser.OPEN_PAR)
            self.state = 417
            self.function_name()
            self.state = 418
            self.match(TeradataParser.OPEN_PAR)
            self.state = 420
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -33552632) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -1) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & -1) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & -1) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & -1) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & -1) != 0) or ((((_la - 448)) & ~0x3f) == 0 and ((1 << (_la - 448)) & 25103) != 0):
                self.state = 419
                self.expr_list()


            self.state = 422
            self.match(TeradataParser.CLOSE_PAR)
            self.state = 423
            self.match(TeradataParser.CLOSE_PAR)
            self.state = 425
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==139:
                self.state = 424
                self.match(TeradataParser.K_AS)


            self.state = 427
            self.derived_table_name()
            self.state = 432
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 428
                self.match(TeradataParser.OPEN_PAR)
                self.state = 429
                self.column_list()
                self.state = 430
                self.match(TeradataParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_with_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WITH(self):
            return self.getToken(TeradataParser.K_WITH, 0)

        def expr_list(self):
            return self.getTypedRuleContext(TeradataParser.Expr_listContext,0)


        def K_BY(self):
            return self.getToken(TeradataParser.K_BY, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.ExprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def K_ASC(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_ASC)
            else:
                return self.getToken(TeradataParser.K_ASC, i)

        def K_DESC(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_DESC)
            else:
                return self.getToken(TeradataParser.K_DESC, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_from_with_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_with_expr" ):
                listener.enterFrom_with_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_with_expr" ):
                listener.exitFrom_with_expr(self)




    def from_with_expr(self):

        localctx = TeradataParser.From_with_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_from_with_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self.match(TeradataParser.K_WITH)
            self.state = 435
            self.expr_list()
            self.state = 451
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 436
                self.match(TeradataParser.K_BY)
                self.state = 437
                self.expr(0)
                self.state = 439
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==145 or _la==212:
                    self.state = 438
                    _la = self._input.LA(1)
                    if not(_la==145 or _la==212):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 448
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 441
                    self.match(TeradataParser.COMMA)
                    self.state = 442
                    self.expr(0)
                    self.state = 444
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==145 or _la==212:
                        self.state = 443
                        _la = self._input.LA(1)
                        if not(_la==145 or _la==212):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 450
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Normalize_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_NORMALIZE(self):
            return self.getToken(TeradataParser.K_NORMALIZE, 0)

        def K_ON(self):
            return self.getToken(TeradataParser.K_ON, 0)

        def K_MEETS(self):
            return self.getToken(TeradataParser.K_MEETS, 0)

        def K_OR(self):
            return self.getToken(TeradataParser.K_OR, 0)

        def K_OVERLAPS(self):
            return self.getToken(TeradataParser.K_OVERLAPS, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_normalize_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNormalize_expr" ):
                listener.enterNormalize_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNormalize_expr" ):
                listener.exitNormalize_expr(self)




    def normalize_expr(self):

        localctx = TeradataParser.Normalize_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_normalize_expr)
        try:
            self.state = 466
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 453
                self.match(TeradataParser.K_NORMALIZE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 454
                self.match(TeradataParser.K_NORMALIZE)
                self.state = 455
                self.match(TeradataParser.K_ON)
                self.state = 456
                self.match(TeradataParser.K_MEETS)
                self.state = 457
                self.match(TeradataParser.K_OR)
                self.state = 458
                self.match(TeradataParser.K_OVERLAPS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 459
                self.match(TeradataParser.K_NORMALIZE)
                self.state = 460
                self.match(TeradataParser.K_ON)
                self.state = 461
                self.match(TeradataParser.K_OVERLAPS)
                self.state = 464
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                if la_ == 1:
                    self.state = 462
                    self.match(TeradataParser.K_OR)
                    self.state = 463
                    self.match(TeradataParser.K_MEETS)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Where_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WHERE(self):
            return self.getToken(TeradataParser.K_WHERE, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TeradataParser.Search_conditionContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_where_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere_clause" ):
                listener.enterWhere_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere_clause" ):
                listener.exitWhere_clause(self)




    def where_clause(self):

        localctx = TeradataParser.Where_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_where_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            self.match(TeradataParser.K_WHERE)
            self.state = 469
            self.search_condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Having_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HAVING(self):
            return self.getToken(TeradataParser.K_HAVING, 0)

        def conditional_expr(self):
            return self.getTypedRuleContext(TeradataParser.Conditional_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_having_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHaving_expr" ):
                listener.enterHaving_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHaving_expr" ):
                listener.exitHaving_expr(self)




    def having_expr(self):

        localctx = TeradataParser.Having_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_having_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(TeradataParser.K_HAVING)
            self.state = 472
            self.conditional_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qualify_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_QUALIFY(self):
            return self.getToken(TeradataParser.K_QUALIFY, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TeradataParser.Search_conditionContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_qualify_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualify_expr" ):
                listener.enterQualify_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualify_expr" ):
                listener.exitQualify_expr(self)




    def qualify_expr(self):

        localctx = TeradataParser.Qualify_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_qualify_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.match(TeradataParser.K_QUALIFY)
            self.state = 475
            self.search_condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sample_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TeradataParser.RULE_sample_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSample_expr" ):
                listener.enterSample_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSample_expr" ):
                listener.exitSample_expr(self)




    def sample_expr(self):

        localctx = TeradataParser.Sample_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_sample_expr)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expand_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TeradataParser.RULE_expand_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpand_expr" ):
                listener.enterExpand_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpand_expr" ):
                listener.exitExpand_expr(self)




    def expand_expr(self):

        localctx = TeradataParser.Expand_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_expand_expr)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_by_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def group_by_val(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Group_by_valContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Group_by_valContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_group_by_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_by_list" ):
                listener.enterGroup_by_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_by_list" ):
                listener.exitGroup_by_list(self)




    def group_by_list(self):

        localctx = TeradataParser.Group_by_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_group_by_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            self.group_by_val()
            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 482
                self.match(TeradataParser.COMMA)
                self.state = 483
                self.group_by_val()
                self.state = 488
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_by_valContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ordinary_grouping_set(self):
            return self.getTypedRuleContext(TeradataParser.Ordinary_grouping_setContext,0)


        def empty_grouping_set(self):
            return self.getTypedRuleContext(TeradataParser.Empty_grouping_setContext,0)


        def rollup_list(self):
            return self.getTypedRuleContext(TeradataParser.Rollup_listContext,0)


        def cube_list(self):
            return self.getTypedRuleContext(TeradataParser.Cube_listContext,0)


        def grouping_sets_specification(self):
            return self.getTypedRuleContext(TeradataParser.Grouping_sets_specificationContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_group_by_val

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_by_val" ):
                listener.enterGroup_by_val(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_by_val" ):
                listener.exitGroup_by_val(self)




    def group_by_val(self):

        localctx = TeradataParser.Group_by_valContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_group_by_val)
        try:
            self.state = 494
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 489
                self.ordinary_grouping_set()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 490
                self.empty_grouping_set()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 491
                self.rollup_list()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 492
                self.cube_list()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 493
                self.grouping_sets_specification()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def order_by_val(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Order_by_valContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Order_by_valContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_order_by_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_list" ):
                listener.enterOrder_by_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_list" ):
                listener.exitOrder_by_list(self)




    def order_by_list(self):

        localctx = TeradataParser.Order_by_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_order_by_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.order_by_val()
            self.state = 501
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 497
                self.match(TeradataParser.COMMA)
                self.state = 498
                self.order_by_val()
                self.state = 503
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_valContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TeradataParser.ExprContext,0)


        def column_name(self):
            return self.getTypedRuleContext(TeradataParser.Column_nameContext,0)


        def column_alias(self):
            return self.getTypedRuleContext(TeradataParser.Column_aliasContext,0)


        def column_position(self):
            return self.getTypedRuleContext(TeradataParser.Column_positionContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_order_by_val

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_val" ):
                listener.enterOrder_by_val(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_val" ):
                listener.exitOrder_by_val(self)




    def order_by_val(self):

        localctx = TeradataParser.Order_by_valContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_order_by_val)
        try:
            self.state = 508
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 504
                self.expr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 505
                self.column_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 506
                self.column_alias()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 507
                self.column_position()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Seed_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_list(self):
            return self.getTypedRuleContext(TeradataParser.Select_listContext,0)


        def K_FROM(self):
            return self.getToken(TeradataParser.K_FROM, 0)

        def from_single_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_single_exprContext,0)


        def K_SELECT(self):
            return self.getToken(TeradataParser.K_SELECT, 0)

        def K_SEL(self):
            return self.getToken(TeradataParser.K_SEL, 0)

        def K_DISTINCT(self):
            return self.getToken(TeradataParser.K_DISTINCT, 0)

        def K_ALL(self):
            return self.getToken(TeradataParser.K_ALL, 0)

        def from_join_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_join_exprContext,0)


        def from_derived_expr(self):
            return self.getTypedRuleContext(TeradataParser.From_derived_exprContext,0)


        def K_WHERE(self):
            return self.getToken(TeradataParser.K_WHERE, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TeradataParser.Search_conditionContext,0)


        def K_GROUP(self):
            return self.getToken(TeradataParser.K_GROUP, 0)

        def K_BY(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_BY)
            else:
                return self.getToken(TeradataParser.K_BY, i)

        def group_by_list(self):
            return self.getTypedRuleContext(TeradataParser.Group_by_listContext,0)


        def having_qualify_expr(self):
            return self.getTypedRuleContext(TeradataParser.Having_qualify_exprContext,0)


        def K_ORDER(self):
            return self.getToken(TeradataParser.K_ORDER, 0)

        def order_by_list(self):
            return self.getTypedRuleContext(TeradataParser.Order_by_listContext,0)


        def K_ASC(self):
            return self.getToken(TeradataParser.K_ASC, 0)

        def K_DESC(self):
            return self.getToken(TeradataParser.K_DESC, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_seed_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSeed_stmt" ):
                listener.enterSeed_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSeed_stmt" ):
                listener.exitSeed_stmt(self)




    def seed_stmt(self):

        localctx = TeradataParser.Seed_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_seed_stmt)
        self._la = 0 # Token type
        try:
            self.state = 538
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [311, 317]:
                self.enterOuterAlt(localctx, 1)
                self.state = 510
                _la = self._input.LA(1)
                if not(_la==311 or _la==317):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 512
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 511
                    _la = self._input.LA(1)
                    if not(_la==103 or _la==242):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 514
                self.select_list()
                self.state = 515
                self.match(TeradataParser.K_FROM)
                self.state = 516
                self.from_single_expr()
                pass
            elif token in [5, 45, 74, 213, 233, 345]:
                self.enterOuterAlt(localctx, 2)
                self.state = 518
                self.from_join_expr()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 3)
                self.state = 519
                self.from_derived_expr()
                self.state = 520
                self.match(TeradataParser.K_WHERE)
                self.state = 521
                self.search_condition()
                self.state = 525
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==99:
                    self.state = 522
                    self.match(TeradataParser.K_GROUP)
                    self.state = 523
                    self.match(TeradataParser.K_BY)
                    self.state = 524
                    self.group_by_list()


                self.state = 528
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==35 or _la==147:
                    self.state = 527
                    self.having_qualify_expr()


                self.state = 536
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==310:
                    self.state = 530
                    self.match(TeradataParser.K_ORDER)
                    self.state = 531
                    self.match(TeradataParser.K_BY)
                    self.state = 532
                    self.order_by_list()
                    self.state = 534
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==145 or _la==212:
                        self.state = 533
                        _la = self._input.LA(1)
                        if not(_la==145 or _la==212):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()




                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal_value(self):
            return self.getTypedRuleContext(TeradataParser.Literal_valueContext,0)


        def column_name(self):
            return self.getTypedRuleContext(TeradataParser.Column_nameContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(TeradataParser.Unary_operatorContext,0)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.ExprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.ExprContext,i)


        def function_name(self):
            return self.getTypedRuleContext(TeradataParser.Function_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(TeradataParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(TeradataParser.CLOSE_PAR, 0)

        def STAR(self):
            return self.getToken(TeradataParser.STAR, 0)

        def K_DISTINCT(self):
            return self.getToken(TeradataParser.K_DISTINCT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def K_CAST(self):
            return self.getToken(TeradataParser.K_CAST, 0)

        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def type_name(self):
            return self.getTypedRuleContext(TeradataParser.Type_nameContext,0)


        def K_CASE(self):
            return self.getToken(TeradataParser.K_CASE, 0)

        def K_END(self):
            return self.getToken(TeradataParser.K_END, 0)

        def K_WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_WHEN)
            else:
                return self.getToken(TeradataParser.K_WHEN, i)

        def K_THEN(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.K_THEN)
            else:
                return self.getToken(TeradataParser.K_THEN, i)

        def K_ELSE(self):
            return self.getToken(TeradataParser.K_ELSE, 0)

        def PIPE2(self):
            return self.getToken(TeradataParser.PIPE2, 0)

        def DIV(self):
            return self.getToken(TeradataParser.DIV, 0)

        def MOD(self):
            return self.getToken(TeradataParser.MOD, 0)

        def PLUS(self):
            return self.getToken(TeradataParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(TeradataParser.MINUS, 0)

        def LT(self):
            return self.getToken(TeradataParser.LT, 0)

        def LT_EQ(self):
            return self.getToken(TeradataParser.LT_EQ, 0)

        def GT(self):
            return self.getToken(TeradataParser.GT, 0)

        def GT_EQ(self):
            return self.getToken(TeradataParser.GT_EQ, 0)

        def ASSIGN(self):
            return self.getToken(TeradataParser.ASSIGN, 0)

        def EQ(self):
            return self.getToken(TeradataParser.EQ, 0)

        def NOT_EQ1(self):
            return self.getToken(TeradataParser.NOT_EQ1, 0)

        def NOT_EQ2(self):
            return self.getToken(TeradataParser.NOT_EQ2, 0)

        def K_IS(self):
            return self.getToken(TeradataParser.K_IS, 0)

        def K_NOT(self):
            return self.getToken(TeradataParser.K_NOT, 0)

        def K_IN(self):
            return self.getToken(TeradataParser.K_IN, 0)

        def K_LIKE(self):
            return self.getToken(TeradataParser.K_LIKE, 0)

        def K_AND(self):
            return self.getToken(TeradataParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(TeradataParser.K_OR, 0)

        def K_BETWEEN(self):
            return self.getToken(TeradataParser.K_BETWEEN, 0)

        def K_ESCAPE(self):
            return self.getToken(TeradataParser.K_ESCAPE, 0)

        def K_NULL(self):
            return self.getToken(TeradataParser.K_NULL, 0)

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def select_expr(self):
            return self.getTypedRuleContext(TeradataParser.Select_exprContext,0)


        def database_name(self):
            return self.getTypedRuleContext(TeradataParser.Database_nameContext,0)


        def DOT(self):
            return self.getToken(TeradataParser.DOT, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TeradataParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 66
        self.enterRecursionRule(localctx, 66, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 594
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.state = 541
                self.literal_value()
                pass

            elif la_ == 2:
                self.state = 542
                self.column_name()
                pass

            elif la_ == 3:
                self.state = 543
                self.unary_operator()
                self.state = 544
                self.expr(17)
                pass

            elif la_ == 4:
                self.state = 546
                self.function_name()
                self.state = 547
                self.match(TeradataParser.OPEN_PAR)
                self.state = 560
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 8, 9, 10, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 457, 461, 462]:
                    self.state = 549
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                    if la_ == 1:
                        self.state = 548
                        self.match(TeradataParser.K_DISTINCT)


                    self.state = 551
                    self.expr(0)
                    self.state = 556
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==5:
                        self.state = 552
                        self.match(TeradataParser.COMMA)
                        self.state = 553
                        self.expr(0)
                        self.state = 558
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                elif token in [7]:
                    self.state = 559
                    self.match(TeradataParser.STAR)
                    pass
                elif token in [4]:
                    pass
                else:
                    pass
                self.state = 562
                self.match(TeradataParser.CLOSE_PAR)
                pass

            elif la_ == 5:
                self.state = 564
                self.match(TeradataParser.OPEN_PAR)
                self.state = 565
                self.expr(0)
                self.state = 566
                self.match(TeradataParser.CLOSE_PAR)
                pass

            elif la_ == 6:
                self.state = 568
                self.match(TeradataParser.K_CAST)
                self.state = 569
                self.match(TeradataParser.OPEN_PAR)
                self.state = 570
                self.expr(0)
                self.state = 571
                self.match(TeradataParser.K_AS)
                self.state = 572
                self.type_name()
                self.state = 573
                self.match(TeradataParser.CLOSE_PAR)
                pass

            elif la_ == 7:
                self.state = 575
                self.match(TeradataParser.K_CASE)
                self.state = 577
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
                if la_ == 1:
                    self.state = 576
                    self.expr(0)


                self.state = 584 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 579
                    self.match(TeradataParser.K_WHEN)
                    self.state = 580
                    self.expr(0)
                    self.state = 581
                    self.match(TeradataParser.K_THEN)
                    self.state = 582
                    self.expr(0)
                    self.state = 586 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==372):
                        break

                self.state = 590
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==290:
                    self.state = 588
                    self.match(TeradataParser.K_ELSE)
                    self.state = 589
                    self.expr(0)


                self.state = 592
                self.match(TeradataParser.K_END)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 690
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,87,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 688
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                    if la_ == 1:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 596
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 597
                        self.match(TeradataParser.PIPE2)
                        self.state = 598
                        self.expr(17)
                        pass

                    elif la_ == 2:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 599
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 600
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 12416) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 601
                        self.expr(16)
                        pass

                    elif la_ == 3:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 602
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 603
                        _la = self._input.LA(1)
                        if not(_la==8 or _la==9):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 604
                        self.expr(15)
                        pass

                    elif la_ == 4:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 605
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 606
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3932160) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 607
                        self.expr(14)
                        pass

                    elif la_ == 5:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 608
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 618
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                        if la_ == 1:
                            self.state = 609
                            self.match(TeradataParser.ASSIGN)
                            pass

                        elif la_ == 2:
                            self.state = 610
                            self.match(TeradataParser.EQ)
                            pass

                        elif la_ == 3:
                            self.state = 611
                            self.match(TeradataParser.NOT_EQ1)
                            pass

                        elif la_ == 4:
                            self.state = 612
                            self.match(TeradataParser.NOT_EQ2)
                            pass

                        elif la_ == 5:
                            self.state = 613
                            self.match(TeradataParser.K_IS)
                            pass

                        elif la_ == 6:
                            self.state = 614
                            self.match(TeradataParser.K_IS)
                            self.state = 615
                            self.match(TeradataParser.K_NOT)
                            pass

                        elif la_ == 7:
                            self.state = 616
                            self.match(TeradataParser.K_IN)
                            pass

                        elif la_ == 8:
                            self.state = 617
                            self.match(TeradataParser.K_LIKE)
                            pass


                        self.state = 620
                        self.expr(13)
                        pass

                    elif la_ == 6:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 621
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 622
                        self.match(TeradataParser.K_AND)
                        self.state = 623
                        self.expr(12)
                        pass

                    elif la_ == 7:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 624
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 625
                        self.match(TeradataParser.K_OR)
                        self.state = 626
                        self.expr(11)
                        pass

                    elif la_ == 8:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 627
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 628
                        self.match(TeradataParser.K_IS)
                        self.state = 630
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                        if la_ == 1:
                            self.state = 629
                            self.match(TeradataParser.K_NOT)


                        self.state = 632
                        self.expr(5)
                        pass

                    elif la_ == 9:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 633
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 635
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==208:
                            self.state = 634
                            self.match(TeradataParser.K_NOT)


                        self.state = 637
                        self.match(TeradataParser.K_BETWEEN)
                        self.state = 638
                        self.expr(0)
                        self.state = 639
                        self.match(TeradataParser.K_AND)
                        self.state = 640
                        self.expr(4)
                        pass

                    elif la_ == 10:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 642
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 644
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==208:
                            self.state = 643
                            self.match(TeradataParser.K_NOT)


                        self.state = 646
                        self.match(TeradataParser.K_LIKE)
                        self.state = 647
                        self.expr(0)
                        self.state = 650
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                        if la_ == 1:
                            self.state = 648
                            self.match(TeradataParser.K_ESCAPE)
                            self.state = 649
                            self.expr(0)


                        pass

                    elif la_ == 11:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 652
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 660
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
                        if la_ == 1:
                            self.state = 653
                            self.match(TeradataParser.K_IS)
                            self.state = 654
                            self.match(TeradataParser.K_NULL)
                            pass

                        elif la_ == 2:
                            self.state = 655
                            self.match(TeradataParser.K_IS)
                            self.state = 656
                            self.match(TeradataParser.K_NOT)
                            self.state = 657
                            self.match(TeradataParser.K_NULL)
                            pass

                        elif la_ == 3:
                            self.state = 658
                            self.match(TeradataParser.K_NOT)
                            self.state = 659
                            self.match(TeradataParser.K_NULL)
                            pass


                        pass

                    elif la_ == 12:
                        localctx = TeradataParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 662
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 664
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==208:
                            self.state = 663
                            self.match(TeradataParser.K_NOT)


                        self.state = 666
                        self.match(TeradataParser.K_IN)
                        self.state = 686
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [3]:
                            self.state = 667
                            self.match(TeradataParser.OPEN_PAR)
                            self.state = 677
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                            if la_ == 1:
                                self.state = 668
                                self.select_expr()

                            elif la_ == 2:
                                self.state = 669
                                self.expr(0)
                                self.state = 674
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)
                                while _la==5:
                                    self.state = 670
                                    self.match(TeradataParser.COMMA)
                                    self.state = 671
                                    self.expr(0)
                                    self.state = 676
                                    self._errHandler.sync(self)
                                    _la = self._input.LA(1)



                            self.state = 679
                            self.match(TeradataParser.CLOSE_PAR)
                            pass
                        elif token in [461]:
                            self.state = 683
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                            if la_ == 1:
                                self.state = 680
                                self.database_name()
                                self.state = 681
                                self.match(TeradataParser.DOT)


                            self.state = 685
                            self.table_name()
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

             
                self.state = 692
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,87,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Expr_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.ExprContext)
            else:
                return self.getTypedRuleContext(TeradataParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_expr_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_list" ):
                listener.enterExpr_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_list" ):
                listener.exitExpr_list(self)




    def expr_list(self):

        localctx = TeradataParser.Expr_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_expr_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 693
            self.expr(0)
            self.state = 698
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 694
                self.match(TeradataParser.COMMA)
                self.state = 695
                self.expr(0)
                self.state = 700
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ordinary_grouping_setContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self):
            return self.getTypedRuleContext(TeradataParser.Column_nameContext,0)


        def column_position(self):
            return self.getTypedRuleContext(TeradataParser.Column_positionContext,0)


        def expr(self):
            return self.getTypedRuleContext(TeradataParser.ExprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_ordinary_grouping_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdinary_grouping_set" ):
                listener.enterOrdinary_grouping_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdinary_grouping_set" ):
                listener.exitOrdinary_grouping_set(self)




    def ordinary_grouping_set(self):

        localctx = TeradataParser.Ordinary_grouping_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_ordinary_grouping_set)
        try:
            self.state = 704
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 701
                self.column_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 702
                self.column_position()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 703
                self.expr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Empty_grouping_setContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(TeradataParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(TeradataParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_empty_grouping_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmpty_grouping_set" ):
                listener.enterEmpty_grouping_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmpty_grouping_set" ):
                listener.exitEmpty_grouping_set(self)




    def empty_grouping_set(self):

        localctx = TeradataParser.Empty_grouping_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_empty_grouping_set)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.match(TeradataParser.OPEN_PAR)
            self.state = 707
            self.match(TeradataParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rollup_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TeradataParser.RULE_rollup_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRollup_list" ):
                listener.enterRollup_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRollup_list" ):
                listener.exitRollup_list(self)




    def rollup_list(self):

        localctx = TeradataParser.Rollup_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_rollup_list)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cube_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TeradataParser.RULE_cube_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCube_list" ):
                listener.enterCube_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCube_list" ):
                listener.exitCube_list(self)




    def cube_list(self):

        localctx = TeradataParser.Cube_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_cube_list)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Grouping_sets_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TeradataParser.RULE_grouping_sets_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrouping_sets_specification" ):
                listener.enterGrouping_sets_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrouping_sets_specification" ):
                listener.exitGrouping_sets_specification(self)




    def grouping_sets_specification(self):

        localctx = TeradataParser.Grouping_sets_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_grouping_sets_specification)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_positionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(TeradataParser.INTEGER, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_column_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_position" ):
                listener.enterColumn_position(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_position" ):
                listener.exitColumn_position(self)




    def column_position(self):

        localctx = TeradataParser.Column_positionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_column_position)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 715
            self.match(TeradataParser.INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubqueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_expr(self):
            return self.getTypedRuleContext(TeradataParser.Select_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubquery" ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubquery" ):
                listener.exitSubquery(self)




    def subquery(self):

        localctx = TeradataParser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_subquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self.select_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Search_conditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TeradataParser.ExprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_search_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSearch_condition" ):
                listener.enterSearch_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSearch_condition" ):
                listener.exitSearch_condition(self)




    def search_condition(self):

        localctx = TeradataParser.Search_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_search_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conditional_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TeradataParser.ExprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_conditional_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_expr" ):
                listener.enterConditional_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_expr" ):
                listener.exitConditional_expr(self)




    def conditional_expr(self):

        localctx = TeradataParser.Conditional_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_conditional_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 721
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TeradataParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(TeradataParser.Column_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_column_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_list" ):
                listener.enterColumn_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_list" ):
                listener.exitColumn_list(self)




    def column_list(self):

        localctx = TeradataParser.Column_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_column_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 723
            self.column_name()
            self.state = 728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 724
                self.match(TeradataParser.COMMA)
                self.state = 725
                self.column_name()
                self.state = 730
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(TeradataParser.NUMERIC_LITERAL, 0)

        def PLUS(self):
            return self.getToken(TeradataParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(TeradataParser.MINUS, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_signed_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_number" ):
                listener.enterSigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_number" ):
                listener.exitSigned_number(self)




    def signed_number(self):

        localctx = TeradataParser.Signed_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_signed_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 732
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8 or _la==9:
                self.state = 731
                _la = self._input.LA(1)
                if not(_la==8 or _la==9):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 734
            self.match(TeradataParser.NUMERIC_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Literal_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(TeradataParser.NUMERIC_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(TeradataParser.STRING_LITERAL, 0)

        def K_NULL(self):
            return self.getToken(TeradataParser.K_NULL, 0)

        def K_CURRENT_TIME(self):
            return self.getToken(TeradataParser.K_CURRENT_TIME, 0)

        def K_CURRENT_DATE(self):
            return self.getToken(TeradataParser.K_CURRENT_DATE, 0)

        def K_CURRENT_TIMESTAMP(self):
            return self.getToken(TeradataParser.K_CURRENT_TIMESTAMP, 0)

        def date_expr(self):
            return self.getTypedRuleContext(TeradataParser.Date_exprContext,0)


        def time_expr(self):
            return self.getTypedRuleContext(TeradataParser.Time_exprContext,0)


        def timestamp_expr(self):
            return self.getTypedRuleContext(TeradataParser.Timestamp_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_literal_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral_value" ):
                listener.enterLiteral_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral_value" ):
                listener.exitLiteral_value(self)




    def literal_value(self):

        localctx = TeradataParser.Literal_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_literal_value)
        try:
            self.state = 745
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 736
                self.match(TeradataParser.NUMERIC_LITERAL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 737
                self.match(TeradataParser.STRING_LITERAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 738
                self.match(TeradataParser.K_NULL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 739
                self.match(TeradataParser.K_CURRENT_TIME)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 740
                self.match(TeradataParser.K_CURRENT_DATE)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 741
                self.match(TeradataParser.K_CURRENT_TIMESTAMP)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 742
                self.date_expr()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 743
                self.time_expr()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 744
                self.timestamp_expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(TeradataParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(TeradataParser.PLUS, 0)

        def TILDE(self):
            return self.getToken(TeradataParser.TILDE, 0)

        def K_NOT(self):
            return self.getToken(TeradataParser.K_NOT, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)




    def unary_operator(self):

        localctx = TeradataParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 747
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1792) != 0) or _la==208):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_aliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_column_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_alias" ):
                listener.enterColumn_alias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_alias" ):
                listener.exitColumn_alias(self)




    def column_alias(self):

        localctx = TeradataParser.Column_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_column_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 749
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Query_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_query_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery_name" ):
                listener.enterQuery_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery_name" ):
                listener.exitQuery_name(self)




    def query_name(self):

        localctx = TeradataParser.Query_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_query_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr_alias_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_expr_alias_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_alias_name" ):
                listener.enterExpr_alias_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_alias_name" ):
                listener.exitExpr_alias_name(self)




    def expr_alias_name(self):

        localctx = TeradataParser.Expr_alias_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_expr_alias_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Joined_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_joined_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoined_table" ):
                listener.enterJoined_table(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoined_table" ):
                listener.exitJoined_table(self)




    def joined_table(self):

        localctx = TeradataParser.Joined_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_joined_table)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 755
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Single_table_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_single_table_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingle_table_expr" ):
                listener.enterSingle_table_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingle_table_expr" ):
                listener.exitSingle_table_expr(self)




    def single_table_expr(self):

        localctx = TeradataParser.Single_table_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_single_table_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 757
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Derived_table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_derived_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerived_table_name" ):
                listener.enterDerived_table_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerived_table_name" ):
                listener.exitDerived_table_name(self)




    def derived_table_name(self):

        localctx = TeradataParser.Derived_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_derived_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 759
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TeradataParser.STRING_LITERAL, 0)

        def K_DATE(self):
            return self.getToken(TeradataParser.K_DATE, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_date_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_expr" ):
                listener.enterDate_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_expr" ):
                listener.exitDate_expr(self)




    def date_expr(self):

        localctx = TeradataParser.Date_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_date_expr)
        self._la = 0 # Token type
        try:
            self.state = 766
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 762
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==152:
                    self.state = 761
                    self.match(TeradataParser.K_DATE)


                self.state = 764
                self.match(TeradataParser.STRING_LITERAL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 765
                self.match(TeradataParser.K_DATE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Timestamp_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TeradataParser.STRING_LITERAL, 0)

        def K_TIMESTAMP(self):
            return self.getToken(TeradataParser.K_TIMESTAMP, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_timestamp_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimestamp_expr" ):
                listener.enterTimestamp_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimestamp_expr" ):
                listener.exitTimestamp_expr(self)




    def timestamp_expr(self):

        localctx = TeradataParser.Timestamp_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_timestamp_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==156:
                self.state = 768
                self.match(TeradataParser.K_TIMESTAMP)


            self.state = 771
            self.match(TeradataParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TeradataParser.STRING_LITERAL, 0)

        def K_TIME(self):
            return self.getToken(TeradataParser.K_TIME, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_time_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_expr" ):
                listener.enterTime_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_expr" ):
                listener.exitTime_expr(self)




    def time_expr(self):

        localctx = TeradataParser.Time_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_time_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 774
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==150:
                self.state = 773
                self.match(TeradataParser.K_TIME)


            self.state = 776
            self.match(TeradataParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_timestamp_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def timestamp_expr(self):
            return self.getTypedRuleContext(TeradataParser.Timestamp_exprContext,0)


        def date_expr(self):
            return self.getTypedRuleContext(TeradataParser.Date_exprContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_date_timestamp_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_timestamp_expr" ):
                listener.enterDate_timestamp_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_timestamp_expr" ):
                listener.exitDate_timestamp_expr(self)




    def date_timestamp_expr(self):

        localctx = TeradataParser.Date_timestamp_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_date_timestamp_expr)
        try:
            self.state = 780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 778
                self.timestamp_expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 779
                self.date_expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ABORT(self):
            return self.getToken(TeradataParser.K_ABORT, 0)

        def K_CONVERT_TABLE_HEADER(self):
            return self.getToken(TeradataParser.K_CONVERT_TABLE_HEADER, 0)

        def K_FOUND(self):
            return self.getToken(TeradataParser.K_FOUND, 0)

        def K_MAX(self):
            return self.getToken(TeradataParser.K_MAX, 0)

        def K_QUALIFIED(self):
            return self.getToken(TeradataParser.K_QUALIFIED, 0)

        def K_STATEMENT(self):
            return self.getToken(TeradataParser.K_STATEMENT, 0)

        def K_ABORTSESSION(self):
            return self.getToken(TeradataParser.K_ABORTSESSION, 0)

        def K_CORR(self):
            return self.getToken(TeradataParser.K_CORR, 0)

        def K_FREESPACE(self):
            return self.getToken(TeradataParser.K_FREESPACE, 0)

        def K_MAXIMUM(self):
            return self.getToken(TeradataParser.K_MAXIMUM, 0)

        def K_QUALIFY(self):
            return self.getToken(TeradataParser.K_QUALIFY, 0)

        def K_STATISTICS(self):
            return self.getToken(TeradataParser.K_STATISTICS, 0)

        def K_ABS(self):
            return self.getToken(TeradataParser.K_ABS, 0)

        def K_COS(self):
            return self.getToken(TeradataParser.K_COS, 0)

        def K_FROM(self):
            return self.getToken(TeradataParser.K_FROM, 0)

        def K_MCHARACTERS(self):
            return self.getToken(TeradataParser.K_MCHARACTERS, 0)

        def K_QUANTILE(self):
            return self.getToken(TeradataParser.K_QUANTILE, 0)

        def K_STDDEV_POP(self):
            return self.getToken(TeradataParser.K_STDDEV_POP, 0)

        def K_ACCESS_LOCK(self):
            return self.getToken(TeradataParser.K_ACCESS_LOCK, 0)

        def K_COSH(self):
            return self.getToken(TeradataParser.K_COSH, 0)

        def K_FULL(self):
            return self.getToken(TeradataParser.K_FULL, 0)

        def K_MDIFF(self):
            return self.getToken(TeradataParser.K_MDIFF, 0)

        def K_RADIANS(self):
            return self.getToken(TeradataParser.K_RADIANS, 0)

        def K_STDDEV_SAMP(self):
            return self.getToken(TeradataParser.K_STDDEV_SAMP, 0)

        def K_ACCOUNT(self):
            return self.getToken(TeradataParser.K_ACCOUNT, 0)

        def K_COUNT(self):
            return self.getToken(TeradataParser.K_COUNT, 0)

        def K_FUNCTION(self):
            return self.getToken(TeradataParser.K_FUNCTION, 0)

        def K_MERGE(self):
            return self.getToken(TeradataParser.K_MERGE, 0)

        def K_RANDOM(self):
            return self.getToken(TeradataParser.K_RANDOM, 0)

        def K_STEPINFO(self):
            return self.getToken(TeradataParser.K_STEPINFO, 0)

        def K_ACOS(self):
            return self.getToken(TeradataParser.K_ACOS, 0)

        def K_COVAR_POP(self):
            return self.getToken(TeradataParser.K_COVAR_POP, 0)

        def K_GE(self):
            return self.getToken(TeradataParser.K_GE, 0)

        def K_MIN(self):
            return self.getToken(TeradataParser.K_MIN, 0)

        def K_RANGE_N(self):
            return self.getToken(TeradataParser.K_RANGE_N, 0)

        def K_STRING_CS(self):
            return self.getToken(TeradataParser.K_STRING_CS, 0)

        def K_ACOSH(self):
            return self.getToken(TeradataParser.K_ACOSH, 0)

        def K_COVAR_SAMP(self):
            return self.getToken(TeradataParser.K_COVAR_SAMP, 0)

        def K_GENERATED(self):
            return self.getToken(TeradataParser.K_GENERATED, 0)

        def K_MINDEX(self):
            return self.getToken(TeradataParser.K_MINDEX, 0)

        def K_RANK(self):
            return self.getToken(TeradataParser.K_RANK, 0)

        def K_SUBSCRIBER(self):
            return self.getToken(TeradataParser.K_SUBSCRIBER, 0)

        def K_ADD(self):
            return self.getToken(TeradataParser.K_ADD, 0)

        def K_CREATE(self):
            return self.getToken(TeradataParser.K_CREATE, 0)

        def K_GIVE(self):
            return self.getToken(TeradataParser.K_GIVE, 0)

        def K_MINIMUM(self):
            return self.getToken(TeradataParser.K_MINIMUM, 0)

        def K_REAL(self):
            return self.getToken(TeradataParser.K_REAL, 0)

        def K_SUBSTR(self):
            return self.getToken(TeradataParser.K_SUBSTR, 0)

        def K_ADD_MONTHS(self):
            return self.getToken(TeradataParser.K_ADD_MONTHS, 0)

        def K_CROSS(self):
            return self.getToken(TeradataParser.K_CROSS, 0)

        def K_GO(self):
            return self.getToken(TeradataParser.K_GO, 0)

        def K_MINUS(self):
            return self.getToken(TeradataParser.K_MINUS, 0)

        def K_REFERENCES(self):
            return self.getToken(TeradataParser.K_REFERENCES, 0)

        def K_SUBSTRING(self):
            return self.getToken(TeradataParser.K_SUBSTRING, 0)

        def K_ADMIN(self):
            return self.getToken(TeradataParser.K_ADMIN, 0)

        def K_CS(self):
            return self.getToken(TeradataParser.K_CS, 0)

        def K_GOTO(self):
            return self.getToken(TeradataParser.K_GOTO, 0)

        def K_MINUTE(self):
            return self.getToken(TeradataParser.K_MINUTE, 0)

        def K_REFERENCING(self):
            return self.getToken(TeradataParser.K_REFERENCING, 0)

        def K_SUM(self):
            return self.getToken(TeradataParser.K_SUM, 0)

        def K_AFTER(self):
            return self.getToken(TeradataParser.K_AFTER, 0)

        def K_CSUM(self):
            return self.getToken(TeradataParser.K_CSUM, 0)

        def K_GRANT(self):
            return self.getToken(TeradataParser.K_GRANT, 0)

        def K_MLINREG(self):
            return self.getToken(TeradataParser.K_MLINREG, 0)

        def K_REGR_AVGX(self):
            return self.getToken(TeradataParser.K_REGR_AVGX, 0)

        def K_SUMMARY(self):
            return self.getToken(TeradataParser.K_SUMMARY, 0)

        def K_AGGREGATE(self):
            return self.getToken(TeradataParser.K_AGGREGATE, 0)

        def K_CT(self):
            return self.getToken(TeradataParser.K_CT, 0)

        def K_GRAPHIC(self):
            return self.getToken(TeradataParser.K_GRAPHIC, 0)

        def K_MLOAD(self):
            return self.getToken(TeradataParser.K_MLOAD, 0)

        def K_REGR_AVGY(self):
            return self.getToken(TeradataParser.K_REGR_AVGY, 0)

        def K_SUSPEND(self):
            return self.getToken(TeradataParser.K_SUSPEND, 0)

        def K_ALIAS(self):
            return self.getToken(TeradataParser.K_ALIAS, 0)

        def K_CURRENT(self):
            return self.getToken(TeradataParser.K_CURRENT, 0)

        def K_GROUP(self):
            return self.getToken(TeradataParser.K_GROUP, 0)

        def K_MOD(self):
            return self.getToken(TeradataParser.K_MOD, 0)

        def K_REGR_COUNT(self):
            return self.getToken(TeradataParser.K_REGR_COUNT, 0)

        def K_TABLE(self):
            return self.getToken(TeradataParser.K_TABLE, 0)

        def K_ALL(self):
            return self.getToken(TeradataParser.K_ALL, 0)

        def K_CURRENT_DATE(self):
            return self.getToken(TeradataParser.K_CURRENT_DATE, 0)

        def K_GT(self):
            return self.getToken(TeradataParser.K_GT, 0)

        def K_MODE(self):
            return self.getToken(TeradataParser.K_MODE, 0)

        def K_REGR_INTERCEPT(self):
            return self.getToken(TeradataParser.K_REGR_INTERCEPT, 0)

        def K_TAN(self):
            return self.getToken(TeradataParser.K_TAN, 0)

        def K_ALTER(self):
            return self.getToken(TeradataParser.K_ALTER, 0)

        def K_CURRENT_TIME(self):
            return self.getToken(TeradataParser.K_CURRENT_TIME, 0)

        def K_HANDLER(self):
            return self.getToken(TeradataParser.K_HANDLER, 0)

        def K_MODIFY(self):
            return self.getToken(TeradataParser.K_MODIFY, 0)

        def K_REGR_R2(self):
            return self.getToken(TeradataParser.K_REGR_R2, 0)

        def K_TANH(self):
            return self.getToken(TeradataParser.K_TANH, 0)

        def K_AMP(self):
            return self.getToken(TeradataParser.K_AMP, 0)

        def K_CURRENT_TIMESTAMP(self):
            return self.getToken(TeradataParser.K_CURRENT_TIMESTAMP, 0)

        def K_HASH(self):
            return self.getToken(TeradataParser.K_HASH, 0)

        def K_MONITOR(self):
            return self.getToken(TeradataParser.K_MONITOR, 0)

        def K_REGR_SLOPE(self):
            return self.getToken(TeradataParser.K_REGR_SLOPE, 0)

        def K_TBL_CS(self):
            return self.getToken(TeradataParser.K_TBL_CS, 0)

        def K_AND(self):
            return self.getToken(TeradataParser.K_AND, 0)

        def K_CURSOR(self):
            return self.getToken(TeradataParser.K_CURSOR, 0)

        def K_HASHAMP(self):
            return self.getToken(TeradataParser.K_HASHAMP, 0)

        def K_MONRESOURCE(self):
            return self.getToken(TeradataParser.K_MONRESOURCE, 0)

        def K_REGR_SXX(self):
            return self.getToken(TeradataParser.K_REGR_SXX, 0)

        def K_TEMPORARY(self):
            return self.getToken(TeradataParser.K_TEMPORARY, 0)

        def K_ANSIDATE(self):
            return self.getToken(TeradataParser.K_ANSIDATE, 0)

        def K_CV(self):
            return self.getToken(TeradataParser.K_CV, 0)

        def K_HASHBAKAMP(self):
            return self.getToken(TeradataParser.K_HASHBAKAMP, 0)

        def K_MONSESSION(self):
            return self.getToken(TeradataParser.K_MONSESSION, 0)

        def K_REGR_SXY(self):
            return self.getToken(TeradataParser.K_REGR_SXY, 0)

        def K_TERMINATE(self):
            return self.getToken(TeradataParser.K_TERMINATE, 0)

        def K_ANY(self):
            return self.getToken(TeradataParser.K_ANY, 0)

        def K_CYCLE(self):
            return self.getToken(TeradataParser.K_CYCLE, 0)

        def K_HASHBUCKET(self):
            return self.getToken(TeradataParser.K_HASHBUCKET, 0)

        def K_MONTH(self):
            return self.getToken(TeradataParser.K_MONTH, 0)

        def K_REGR_SYY(self):
            return self.getToken(TeradataParser.K_REGR_SYY, 0)

        def K_THEN(self):
            return self.getToken(TeradataParser.K_THEN, 0)

        def K_AS(self):
            return self.getToken(TeradataParser.K_AS, 0)

        def K_DATABASE(self):
            return self.getToken(TeradataParser.K_DATABASE, 0)

        def K_HASHROW(self):
            return self.getToken(TeradataParser.K_HASHROW, 0)

        def K_MSUBSTR(self):
            return self.getToken(TeradataParser.K_MSUBSTR, 0)

        def K_RELEASE(self):
            return self.getToken(TeradataParser.K_RELEASE, 0)

        def K_THRESHOLD(self):
            return self.getToken(TeradataParser.K_THRESHOLD, 0)

        def K_ASC(self):
            return self.getToken(TeradataParser.K_ASC, 0)

        def K_DATABLOCKSIZE(self):
            return self.getToken(TeradataParser.K_DATABLOCKSIZE, 0)

        def K_HAVING(self):
            return self.getToken(TeradataParser.K_HAVING, 0)

        def K_MSUM(self):
            return self.getToken(TeradataParser.K_MSUM, 0)

        def K_RENAME(self):
            return self.getToken(TeradataParser.K_RENAME, 0)

        def K_TIME(self):
            return self.getToken(TeradataParser.K_TIME, 0)

        def K_ASIN(self):
            return self.getToken(TeradataParser.K_ASIN, 0)

        def K_DATE(self):
            return self.getToken(TeradataParser.K_DATE, 0)

        def K_HELP(self):
            return self.getToken(TeradataParser.K_HELP, 0)

        def K_MULTISET(self):
            return self.getToken(TeradataParser.K_MULTISET, 0)

        def K_REPEAT(self):
            return self.getToken(TeradataParser.K_REPEAT, 0)

        def K_TIMESTAMP(self):
            return self.getToken(TeradataParser.K_TIMESTAMP, 0)

        def K_ASINH(self):
            return self.getToken(TeradataParser.K_ASINH, 0)

        def K_DATEFORM(self):
            return self.getToken(TeradataParser.K_DATEFORM, 0)

        def K_HOUR(self):
            return self.getToken(TeradataParser.K_HOUR, 0)

        def K_NAMED(self):
            return self.getToken(TeradataParser.K_NAMED, 0)

        def K_REPLACE(self):
            return self.getToken(TeradataParser.K_REPLACE, 0)

        def K_TIMEZONE_HOUR(self):
            return self.getToken(TeradataParser.K_TIMEZONE_HOUR, 0)

        def K_AT(self):
            return self.getToken(TeradataParser.K_AT, 0)

        def K_DAY(self):
            return self.getToken(TeradataParser.K_DAY, 0)

        def K_IDENTITY(self):
            return self.getToken(TeradataParser.K_IDENTITY, 0)

        def K_NATURAL(self):
            return self.getToken(TeradataParser.K_NATURAL, 0)

        def K_REPLICATION(self):
            return self.getToken(TeradataParser.K_REPLICATION, 0)

        def K_TIMEZONE_MINUTE(self):
            return self.getToken(TeradataParser.K_TIMEZONE_MINUTE, 0)

        def K_ATAN(self):
            return self.getToken(TeradataParser.K_ATAN, 0)

        def K_DEC(self):
            return self.getToken(TeradataParser.K_DEC, 0)

        def K_IF(self):
            return self.getToken(TeradataParser.K_IF, 0)

        def K_NE(self):
            return self.getToken(TeradataParser.K_NE, 0)

        def K_REPOVERRIDE(self):
            return self.getToken(TeradataParser.K_REPOVERRIDE, 0)

        def K_TITLE(self):
            return self.getToken(TeradataParser.K_TITLE, 0)

        def K_ATAN2(self):
            return self.getToken(TeradataParser.K_ATAN2, 0)

        def K_DECIMAL(self):
            return self.getToken(TeradataParser.K_DECIMAL, 0)

        def K_IMMEDIATE(self):
            return self.getToken(TeradataParser.K_IMMEDIATE, 0)

        def K_NEW(self):
            return self.getToken(TeradataParser.K_NEW, 0)

        def K_REQUEST(self):
            return self.getToken(TeradataParser.K_REQUEST, 0)

        def K_TO(self):
            return self.getToken(TeradataParser.K_TO, 0)

        def K_ATANH(self):
            return self.getToken(TeradataParser.K_ATANH, 0)

        def K_DECLARE(self):
            return self.getToken(TeradataParser.K_DECLARE, 0)

        def K_IN(self):
            return self.getToken(TeradataParser.K_IN, 0)

        def K_NEW_TABLE(self):
            return self.getToken(TeradataParser.K_NEW_TABLE, 0)

        def K_RESTART(self):
            return self.getToken(TeradataParser.K_RESTART, 0)

        def K_TRACE(self):
            return self.getToken(TeradataParser.K_TRACE, 0)

        def K_ATOMIC(self):
            return self.getToken(TeradataParser.K_ATOMIC, 0)

        def K_DEFAULT(self):
            return self.getToken(TeradataParser.K_DEFAULT, 0)

        def K_INCONSISTENT(self):
            return self.getToken(TeradataParser.K_INCONSISTENT, 0)

        def K_NEXT(self):
            return self.getToken(TeradataParser.K_NEXT, 0)

        def K_RESTORE(self):
            return self.getToken(TeradataParser.K_RESTORE, 0)

        def K_TRAILING(self):
            return self.getToken(TeradataParser.K_TRAILING, 0)

        def K_AUTHORIZATION(self):
            return self.getToken(TeradataParser.K_AUTHORIZATION, 0)

        def K_DEGREES(self):
            return self.getToken(TeradataParser.K_DEGREES, 0)

        def K_INDEX(self):
            return self.getToken(TeradataParser.K_INDEX, 0)

        def K_NO(self):
            return self.getToken(TeradataParser.K_NO, 0)

        def K_RESUME(self):
            return self.getToken(TeradataParser.K_RESUME, 0)

        def K_TRANSACTION(self):
            return self.getToken(TeradataParser.K_TRANSACTION, 0)

        def K_AVE(self):
            return self.getToken(TeradataParser.K_AVE, 0)

        def K_DEL(self):
            return self.getToken(TeradataParser.K_DEL, 0)

        def K_INDICATOR(self):
            return self.getToken(TeradataParser.K_INDICATOR, 0)

        def K_NONE(self):
            return self.getToken(TeradataParser.K_NONE, 0)

        def K_RET(self):
            return self.getToken(TeradataParser.K_RET, 0)

        def K_TRANSLATE(self):
            return self.getToken(TeradataParser.K_TRANSLATE, 0)

        def K_AVERAGE(self):
            return self.getToken(TeradataParser.K_AVERAGE, 0)

        def K_DELETE(self):
            return self.getToken(TeradataParser.K_DELETE, 0)

        def K_INITIATE(self):
            return self.getToken(TeradataParser.K_INITIATE, 0)

        def K_NOT(self):
            return self.getToken(TeradataParser.K_NOT, 0)

        def K_RETRIEVE(self):
            return self.getToken(TeradataParser.K_RETRIEVE, 0)

        def K_TRANSLATE_CHK(self):
            return self.getToken(TeradataParser.K_TRANSLATE_CHK, 0)

        def K_AVG(self):
            return self.getToken(TeradataParser.K_AVG, 0)

        def K_DESC(self):
            return self.getToken(TeradataParser.K_DESC, 0)

        def K_INNER(self):
            return self.getToken(TeradataParser.K_INNER, 0)

        def K_NOWAIT(self):
            return self.getToken(TeradataParser.K_NOWAIT, 0)

        def K_RETURNS(self):
            return self.getToken(TeradataParser.K_RETURNS, 0)

        def K_TRIGGER(self):
            return self.getToken(TeradataParser.K_TRIGGER, 0)

        def K_BEFORE(self):
            return self.getToken(TeradataParser.K_BEFORE, 0)

        def K_DESCRIPTOR(self):
            return self.getToken(TeradataParser.K_DESCRIPTOR, 0)

        def K_INOUT(self):
            return self.getToken(TeradataParser.K_INOUT, 0)

        def K_NULL(self):
            return self.getToken(TeradataParser.K_NULL, 0)

        def K_REVALIDATE(self):
            return self.getToken(TeradataParser.K_REVALIDATE, 0)

        def K_TRIM(self):
            return self.getToken(TeradataParser.K_TRIM, 0)

        def K_BEGIN(self):
            return self.getToken(TeradataParser.K_BEGIN, 0)

        def K_DETERMINISTIC(self):
            return self.getToken(TeradataParser.K_DETERMINISTIC, 0)

        def K_INPUT(self):
            return self.getToken(TeradataParser.K_INPUT, 0)

        def K_NULLIF(self):
            return self.getToken(TeradataParser.K_NULLIF, 0)

        def K_REVOKE(self):
            return self.getToken(TeradataParser.K_REVOKE, 0)

        def K_TYPE(self):
            return self.getToken(TeradataParser.K_TYPE, 0)

        def K_BETWEEN(self):
            return self.getToken(TeradataParser.K_BETWEEN, 0)

        def K_DIAGNOSTIC(self):
            return self.getToken(TeradataParser.K_DIAGNOSTIC, 0)

        def K_INS(self):
            return self.getToken(TeradataParser.K_INS, 0)

        def K_NULLIFZERO(self):
            return self.getToken(TeradataParser.K_NULLIFZERO, 0)

        def K_RIGHT(self):
            return self.getToken(TeradataParser.K_RIGHT, 0)

        def K_UC(self):
            return self.getToken(TeradataParser.K_UC, 0)

        def K_BLOB(self):
            return self.getToken(TeradataParser.K_BLOB, 0)

        def K_DISABLED(self):
            return self.getToken(TeradataParser.K_DISABLED, 0)

        def K_INSERT(self):
            return self.getToken(TeradataParser.K_INSERT, 0)

        def K_NUMERIC(self):
            return self.getToken(TeradataParser.K_NUMERIC, 0)

        def K_RIGHTS(self):
            return self.getToken(TeradataParser.K_RIGHTS, 0)

        def K_UNDEFINED(self):
            return self.getToken(TeradataParser.K_UNDEFINED, 0)

        def K_BOTH(self):
            return self.getToken(TeradataParser.K_BOTH, 0)

        def K_DISTINCT(self):
            return self.getToken(TeradataParser.K_DISTINCT, 0)

        def K_INSTEAD(self):
            return self.getToken(TeradataParser.K_INSTEAD, 0)

        def K_OBJECTS(self):
            return self.getToken(TeradataParser.K_OBJECTS, 0)

        def K_ROLE(self):
            return self.getToken(TeradataParser.K_ROLE, 0)

        def K_UNDO(self):
            return self.getToken(TeradataParser.K_UNDO, 0)

        def K_BT(self):
            return self.getToken(TeradataParser.K_BT, 0)

        def K_DO(self):
            return self.getToken(TeradataParser.K_DO, 0)

        def K_INT(self):
            return self.getToken(TeradataParser.K_INT, 0)

        def K_OCTET_LENGTH(self):
            return self.getToken(TeradataParser.K_OCTET_LENGTH, 0)

        def K_ROLLBACK(self):
            return self.getToken(TeradataParser.K_ROLLBACK, 0)

        def K_UNION(self):
            return self.getToken(TeradataParser.K_UNION, 0)

        def K_BUT(self):
            return self.getToken(TeradataParser.K_BUT, 0)

        def K_DOUBLE(self):
            return self.getToken(TeradataParser.K_DOUBLE, 0)

        def K_INTEGER(self):
            return self.getToken(TeradataParser.K_INTEGER, 0)

        def K_OF(self):
            return self.getToken(TeradataParser.K_OF, 0)

        def K_ROLLFORWARD(self):
            return self.getToken(TeradataParser.K_ROLLFORWARD, 0)

        def K_UNIQUE(self):
            return self.getToken(TeradataParser.K_UNIQUE, 0)

        def K_BY(self):
            return self.getToken(TeradataParser.K_BY, 0)

        def K_DROP(self):
            return self.getToken(TeradataParser.K_DROP, 0)

        def K_INTEGERDATE(self):
            return self.getToken(TeradataParser.K_INTEGERDATE, 0)

        def K_OFF(self):
            return self.getToken(TeradataParser.K_OFF, 0)

        def K_ROW(self):
            return self.getToken(TeradataParser.K_ROW, 0)

        def K_UNTIL(self):
            return self.getToken(TeradataParser.K_UNTIL, 0)

        def K_BYTE(self):
            return self.getToken(TeradataParser.K_BYTE, 0)

        def K_DUAL(self):
            return self.getToken(TeradataParser.K_DUAL, 0)

        def K_INTERSECT(self):
            return self.getToken(TeradataParser.K_INTERSECT, 0)

        def K_OLD(self):
            return self.getToken(TeradataParser.K_OLD, 0)

        def K_ROWID(self):
            return self.getToken(TeradataParser.K_ROWID, 0)

        def K_UPD(self):
            return self.getToken(TeradataParser.K_UPD, 0)

        def K_BYTEINT(self):
            return self.getToken(TeradataParser.K_BYTEINT, 0)

        def K_DUMP(self):
            return self.getToken(TeradataParser.K_DUMP, 0)

        def K_INTERVAL(self):
            return self.getToken(TeradataParser.K_INTERVAL, 0)

        def K_OLD_TABLE(self):
            return self.getToken(TeradataParser.K_OLD_TABLE, 0)

        def K_ROWS(self):
            return self.getToken(TeradataParser.K_ROWS, 0)

        def K_UPDATE(self):
            return self.getToken(TeradataParser.K_UPDATE, 0)

        def K_BYTES(self):
            return self.getToken(TeradataParser.K_BYTES, 0)

        def K_EACH(self):
            return self.getToken(TeradataParser.K_EACH, 0)

        def K_INTO(self):
            return self.getToken(TeradataParser.K_INTO, 0)

        def K_ON(self):
            return self.getToken(TeradataParser.K_ON, 0)

        def K_ROW_NUMBER(self):
            return self.getToken(TeradataParser.K_ROW_NUMBER, 0)

        def K_UPPER(self):
            return self.getToken(TeradataParser.K_UPPER, 0)

        def K_CALL(self):
            return self.getToken(TeradataParser.K_CALL, 0)

        def K_ECHO(self):
            return self.getToken(TeradataParser.K_ECHO, 0)

        def K_IS(self):
            return self.getToken(TeradataParser.K_IS, 0)

        def K_ONLY(self):
            return self.getToken(TeradataParser.K_ONLY, 0)

        def K_SAMPLE(self):
            return self.getToken(TeradataParser.K_SAMPLE, 0)

        def K_UPPERCASE(self):
            return self.getToken(TeradataParser.K_UPPERCASE, 0)

        def K_CASE(self):
            return self.getToken(TeradataParser.K_CASE, 0)

        def K_ELSE(self):
            return self.getToken(TeradataParser.K_ELSE, 0)

        def K_ITERATE(self):
            return self.getToken(TeradataParser.K_ITERATE, 0)

        def K_OPEN(self):
            return self.getToken(TeradataParser.K_OPEN, 0)

        def K_SAMPLEID(self):
            return self.getToken(TeradataParser.K_SAMPLEID, 0)

        def K_USER(self):
            return self.getToken(TeradataParser.K_USER, 0)

        def K_CASESPECIFIC(self):
            return self.getToken(TeradataParser.K_CASESPECIFIC, 0)

        def K_ELSEIF(self):
            return self.getToken(TeradataParser.K_ELSEIF, 0)

        def K_JOIN(self):
            return self.getToken(TeradataParser.K_JOIN, 0)

        def K_OPTION(self):
            return self.getToken(TeradataParser.K_OPTION, 0)

        def K_SCROLL(self):
            return self.getToken(TeradataParser.K_SCROLL, 0)

        def K_USING(self):
            return self.getToken(TeradataParser.K_USING, 0)

        def K_CASE_N(self):
            return self.getToken(TeradataParser.K_CASE_N, 0)

        def K_ENABLED(self):
            return self.getToken(TeradataParser.K_ENABLED, 0)

        def K_JOURNAL(self):
            return self.getToken(TeradataParser.K_JOURNAL, 0)

        def K_OR(self):
            return self.getToken(TeradataParser.K_OR, 0)

        def K_SECOND(self):
            return self.getToken(TeradataParser.K_SECOND, 0)

        def K_VALUE(self):
            return self.getToken(TeradataParser.K_VALUE, 0)

        def K_CAST(self):
            return self.getToken(TeradataParser.K_CAST, 0)

        def K_END(self):
            return self.getToken(TeradataParser.K_END, 0)

        def K_KEY(self):
            return self.getToken(TeradataParser.K_KEY, 0)

        def K_ORDER(self):
            return self.getToken(TeradataParser.K_ORDER, 0)

        def K_SEL(self):
            return self.getToken(TeradataParser.K_SEL, 0)

        def K_VALUES(self):
            return self.getToken(TeradataParser.K_VALUES, 0)

        def K_CD(self):
            return self.getToken(TeradataParser.K_CD, 0)

        def K_EQ(self):
            return self.getToken(TeradataParser.K_EQ, 0)

        def K_KURTOSIS(self):
            return self.getToken(TeradataParser.K_KURTOSIS, 0)

        def K_OUT(self):
            return self.getToken(TeradataParser.K_OUT, 0)

        def K_SELECT(self):
            return self.getToken(TeradataParser.K_SELECT, 0)

        def K_VARBYTE(self):
            return self.getToken(TeradataParser.K_VARBYTE, 0)

        def K_CHAR(self):
            return self.getToken(TeradataParser.K_CHAR, 0)

        def K_ERROR(self):
            return self.getToken(TeradataParser.K_ERROR, 0)

        def K_LANGUAGE(self):
            return self.getToken(TeradataParser.K_LANGUAGE, 0)

        def K_OUTER(self):
            return self.getToken(TeradataParser.K_OUTER, 0)

        def K_SESSION(self):
            return self.getToken(TeradataParser.K_SESSION, 0)

        def K_VARCHAR(self):
            return self.getToken(TeradataParser.K_VARCHAR, 0)

        def K_CHAR2HEXINT(self):
            return self.getToken(TeradataParser.K_CHAR2HEXINT, 0)

        def K_ERRORFILES(self):
            return self.getToken(TeradataParser.K_ERRORFILES, 0)

        def K_LE(self):
            return self.getToken(TeradataParser.K_LE, 0)

        def K_OVER(self):
            return self.getToken(TeradataParser.K_OVER, 0)

        def K_SET(self):
            return self.getToken(TeradataParser.K_SET, 0)

        def K_VARGRAPHIC(self):
            return self.getToken(TeradataParser.K_VARGRAPHIC, 0)

        def K_CHARACTER(self):
            return self.getToken(TeradataParser.K_CHARACTER, 0)

        def K_ERRORTABLES(self):
            return self.getToken(TeradataParser.K_ERRORTABLES, 0)

        def K_LEADING(self):
            return self.getToken(TeradataParser.K_LEADING, 0)

        def K_OVERLAPS(self):
            return self.getToken(TeradataParser.K_OVERLAPS, 0)

        def K_SETRESRATE(self):
            return self.getToken(TeradataParser.K_SETRESRATE, 0)

        def K_VARYING(self):
            return self.getToken(TeradataParser.K_VARYING, 0)

        def K_CHARACTERS(self):
            return self.getToken(TeradataParser.K_CHARACTERS, 0)

        def K_ESCAPE(self):
            return self.getToken(TeradataParser.K_ESCAPE, 0)

        def K_LEAVE(self):
            return self.getToken(TeradataParser.K_LEAVE, 0)

        def K_OVERRIDE(self):
            return self.getToken(TeradataParser.K_OVERRIDE, 0)

        def K_SETSESSRATE(self):
            return self.getToken(TeradataParser.K_SETSESSRATE, 0)

        def K_VAR_POP(self):
            return self.getToken(TeradataParser.K_VAR_POP, 0)

        def K_CHARACTER_LENGTH(self):
            return self.getToken(TeradataParser.K_CHARACTER_LENGTH, 0)

        def K_ET(self):
            return self.getToken(TeradataParser.K_ET, 0)

        def K_LEFT(self):
            return self.getToken(TeradataParser.K_LEFT, 0)

        def K_PARAMETER(self):
            return self.getToken(TeradataParser.K_PARAMETER, 0)

        def K_SHOW(self):
            return self.getToken(TeradataParser.K_SHOW, 0)

        def K_VAR_SAMP(self):
            return self.getToken(TeradataParser.K_VAR_SAMP, 0)

        def K_CHARS(self):
            return self.getToken(TeradataParser.K_CHARS, 0)

        def K_EXCEPT(self):
            return self.getToken(TeradataParser.K_EXCEPT, 0)

        def K_LIKE(self):
            return self.getToken(TeradataParser.K_LIKE, 0)

        def K_PASSWORD(self):
            return self.getToken(TeradataParser.K_PASSWORD, 0)

        def K_SIMPLE(self):
            return self.getToken(TeradataParser.K_SIMPLE, 0)

        def K_VIEW(self):
            return self.getToken(TeradataParser.K_VIEW, 0)

        def K_CHAR_LENGTH(self):
            return self.getToken(TeradataParser.K_CHAR_LENGTH, 0)

        def K_EXEC(self):
            return self.getToken(TeradataParser.K_EXEC, 0)

        def K_LIMIT(self):
            return self.getToken(TeradataParser.K_LIMIT, 0)

        def K_PERCENT(self):
            return self.getToken(TeradataParser.K_PERCENT, 0)

        def K_SIN(self):
            return self.getToken(TeradataParser.K_SIN, 0)

        def K_VOLATILE(self):
            return self.getToken(TeradataParser.K_VOLATILE, 0)

        def K_CHECK(self):
            return self.getToken(TeradataParser.K_CHECK, 0)

        def K_EXECUTE(self):
            return self.getToken(TeradataParser.K_EXECUTE, 0)

        def K_LN(self):
            return self.getToken(TeradataParser.K_LN, 0)

        def K_PERCENT_RANK(self):
            return self.getToken(TeradataParser.K_PERCENT_RANK, 0)

        def K_SINH(self):
            return self.getToken(TeradataParser.K_SINH, 0)

        def K_WAIT(self):
            return self.getToken(TeradataParser.K_WAIT, 0)

        def K_CHECKPOINT(self):
            return self.getToken(TeradataParser.K_CHECKPOINT, 0)

        def K_EXISTS(self):
            return self.getToken(TeradataParser.K_EXISTS, 0)

        def K_LOADING(self):
            return self.getToken(TeradataParser.K_LOADING, 0)

        def K_PERM(self):
            return self.getToken(TeradataParser.K_PERM, 0)

        def K_SKEW(self):
            return self.getToken(TeradataParser.K_SKEW, 0)

        def K_WHEN(self):
            return self.getToken(TeradataParser.K_WHEN, 0)

        def K_CLASS(self):
            return self.getToken(TeradataParser.K_CLASS, 0)

        def K_EXIT(self):
            return self.getToken(TeradataParser.K_EXIT, 0)

        def K_LOCAL(self):
            return self.getToken(TeradataParser.K_LOCAL, 0)

        def K_PERMANENT(self):
            return self.getToken(TeradataParser.K_PERMANENT, 0)

        def K_SMALLINT(self):
            return self.getToken(TeradataParser.K_SMALLINT, 0)

        def K_WHERE(self):
            return self.getToken(TeradataParser.K_WHERE, 0)

        def K_CLOSE(self):
            return self.getToken(TeradataParser.K_CLOSE, 0)

        def K_EXP(self):
            return self.getToken(TeradataParser.K_EXP, 0)

        def K_LOCATOR(self):
            return self.getToken(TeradataParser.K_LOCATOR, 0)

        def K_POSITION(self):
            return self.getToken(TeradataParser.K_POSITION, 0)

        def K_SOME(self):
            return self.getToken(TeradataParser.K_SOME, 0)

        def K_WHILE(self):
            return self.getToken(TeradataParser.K_WHILE, 0)

        def K_CLUSTER(self):
            return self.getToken(TeradataParser.K_CLUSTER, 0)

        def K_EXPLAIN(self):
            return self.getToken(TeradataParser.K_EXPLAIN, 0)

        def K_LOCK(self):
            return self.getToken(TeradataParser.K_LOCK, 0)

        def K_PRECISION(self):
            return self.getToken(TeradataParser.K_PRECISION, 0)

        def K_SOUNDEX(self):
            return self.getToken(TeradataParser.K_SOUNDEX, 0)

        def K_WIDTH_BUCKET(self):
            return self.getToken(TeradataParser.K_WIDTH_BUCKET, 0)

        def K_CM(self):
            return self.getToken(TeradataParser.K_CM, 0)

        def K_EXTERNAL(self):
            return self.getToken(TeradataParser.K_EXTERNAL, 0)

        def K_LOCKING(self):
            return self.getToken(TeradataParser.K_LOCKING, 0)

        def K_PREPARE(self):
            return self.getToken(TeradataParser.K_PREPARE, 0)

        def K_SPECIFIC(self):
            return self.getToken(TeradataParser.K_SPECIFIC, 0)

        def K_WITH(self):
            return self.getToken(TeradataParser.K_WITH, 0)

        def K_COALESCE(self):
            return self.getToken(TeradataParser.K_COALESCE, 0)

        def K_EXTRACT(self):
            return self.getToken(TeradataParser.K_EXTRACT, 0)

        def K_LOG(self):
            return self.getToken(TeradataParser.K_LOG, 0)

        def K_PRESERVE(self):
            return self.getToken(TeradataParser.K_PRESERVE, 0)

        def K_SPOOL(self):
            return self.getToken(TeradataParser.K_SPOOL, 0)

        def K_WITHOUT(self):
            return self.getToken(TeradataParser.K_WITHOUT, 0)

        def K_COLLATION(self):
            return self.getToken(TeradataParser.K_COLLATION, 0)

        def K_FALLBACK(self):
            return self.getToken(TeradataParser.K_FALLBACK, 0)

        def K_LOGGING(self):
            return self.getToken(TeradataParser.K_LOGGING, 0)

        def K_PRIMARY(self):
            return self.getToken(TeradataParser.K_PRIMARY, 0)

        def K_SQL(self):
            return self.getToken(TeradataParser.K_SQL, 0)

        def K_WORK(self):
            return self.getToken(TeradataParser.K_WORK, 0)

        def K_COLLECT(self):
            return self.getToken(TeradataParser.K_COLLECT, 0)

        def K_FASTEXPORT(self):
            return self.getToken(TeradataParser.K_FASTEXPORT, 0)

        def K_LOGON(self):
            return self.getToken(TeradataParser.K_LOGON, 0)

        def K_PRIVATE(self):
            return self.getToken(TeradataParser.K_PRIVATE, 0)

        def K_SQLEXCEPTION(self):
            return self.getToken(TeradataParser.K_SQLEXCEPTION, 0)

        def K_YEAR(self):
            return self.getToken(TeradataParser.K_YEAR, 0)

        def K_COLUMN(self):
            return self.getToken(TeradataParser.K_COLUMN, 0)

        def K_FETCH(self):
            return self.getToken(TeradataParser.K_FETCH, 0)

        def K_LONG(self):
            return self.getToken(TeradataParser.K_LONG, 0)

        def K_PRIVILEGES(self):
            return self.getToken(TeradataParser.K_PRIVILEGES, 0)

        def K_SQLTEXT(self):
            return self.getToken(TeradataParser.K_SQLTEXT, 0)

        def K_ZEROIFNULL(self):
            return self.getToken(TeradataParser.K_ZEROIFNULL, 0)

        def K_COMMENT(self):
            return self.getToken(TeradataParser.K_COMMENT, 0)

        def K_FIRST(self):
            return self.getToken(TeradataParser.K_FIRST, 0)

        def K_LOOP(self):
            return self.getToken(TeradataParser.K_LOOP, 0)

        def K_PROCEDURE(self):
            return self.getToken(TeradataParser.K_PROCEDURE, 0)

        def K_SQLWARNING(self):
            return self.getToken(TeradataParser.K_SQLWARNING, 0)

        def K_ZONE(self):
            return self.getToken(TeradataParser.K_ZONE, 0)

        def K_COMMIT(self):
            return self.getToken(TeradataParser.K_COMMIT, 0)

        def K_FLOAT(self):
            return self.getToken(TeradataParser.K_FLOAT, 0)

        def K_LOWER(self):
            return self.getToken(TeradataParser.K_LOWER, 0)

        def K_PROFILE(self):
            return self.getToken(TeradataParser.K_PROFILE, 0)

        def K_SQRT(self):
            return self.getToken(TeradataParser.K_SQRT, 0)

        def K_COMPRESS(self):
            return self.getToken(TeradataParser.K_COMPRESS, 0)

        def K_FOR(self):
            return self.getToken(TeradataParser.K_FOR, 0)

        def K_LT(self):
            return self.getToken(TeradataParser.K_LT, 0)

        def K_PROPORTIONAL(self):
            return self.getToken(TeradataParser.K_PROPORTIONAL, 0)

        def K_SS(self):
            return self.getToken(TeradataParser.K_SS, 0)

        def K_CONSTRAINT(self):
            return self.getToken(TeradataParser.K_CONSTRAINT, 0)

        def K_FOREIGN(self):
            return self.getToken(TeradataParser.K_FOREIGN, 0)

        def K_MACRO(self):
            return self.getToken(TeradataParser.K_MACRO, 0)

        def K_PROTECTION(self):
            return self.getToken(TeradataParser.K_PROTECTION, 0)

        def K_START(self):
            return self.getToken(TeradataParser.K_START, 0)

        def K_CONTINUE(self):
            return self.getToken(TeradataParser.K_CONTINUE, 0)

        def K_FORMAT(self):
            return self.getToken(TeradataParser.K_FORMAT, 0)

        def K_MAVG(self):
            return self.getToken(TeradataParser.K_MAVG, 0)

        def K_PUBLIC(self):
            return self.getToken(TeradataParser.K_PUBLIC, 0)

        def K_STARTUP(self):
            return self.getToken(TeradataParser.K_STARTUP, 0)

        def K_TOP(self):
            return self.getToken(TeradataParser.K_TOP, 0)

        def K_TIES(self):
            return self.getToken(TeradataParser.K_TIES, 0)

        def K_VALIDTIME(self):
            return self.getToken(TeradataParser.K_VALIDTIME, 0)

        def K_TRANSACTIONTIME(self):
            return self.getToken(TeradataParser.K_TRANSACTIONTIME, 0)

        def K_BIGINT(self):
            return self.getToken(TeradataParser.K_BIGINT, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)




    def keyword(self):

        localctx = TeradataParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_keyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            _la = self._input.LA(1)
            if not(((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & -1) != 0) or ((((_la - 89)) & ~0x3f) == 0 and ((1 << (_la - 89)) & -1) != 0) or ((((_la - 153)) & ~0x3f) == 0 and ((1 << (_la - 153)) & -1) != 0) or ((((_la - 217)) & ~0x3f) == 0 and ((1 << (_la - 217)) & -1) != 0) or ((((_la - 281)) & ~0x3f) == 0 and ((1 << (_la - 281)) & -1) != 0) or ((((_la - 345)) & ~0x3f) == 0 and ((1 << (_la - 345)) & -1) != 0) or ((((_la - 409)) & ~0x3f) == 0 and ((1 << (_la - 409)) & 8796093022207) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(TeradataParser.Any_nameContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)




    def name(self):

        localctx = TeradataParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 784
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def keyword(self):
            return self.getTypedRuleContext(TeradataParser.KeywordContext,0)


        def getRuleIndex(self):
            return TeradataParser.RULE_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_name" ):
                listener.enterFunction_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_name" ):
                listener.exitFunction_name(self)




    def function_name(self):

        localctx = TeradataParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_function_name)
        try:
            self.state = 788
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [461]:
                self.enterOuterAlt(localctx, 1)
                self.state = 786
                self.match(TeradataParser.IDENTIFIER)
                pass
            elif token in [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451]:
                self.enterOuterAlt(localctx, 2)
                self.state = 787
                self.keyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Database_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_database_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabase_name" ):
                listener.enterDatabase_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabase_name" ):
                listener.exitDatabase_name(self)




    def database_name(self):

        localctx = TeradataParser.Database_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_database_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def database_name(self):
            return self.getTypedRuleContext(TeradataParser.Database_nameContext,0)


        def DOT(self):
            return self.getToken(TeradataParser.DOT, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_name" ):
                listener.enterTable_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_name" ):
                listener.exitTable_name(self)




    def table_name(self):

        localctx = TeradataParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 792
                self.database_name()
                self.state = 793
                self.match(TeradataParser.DOT)


            self.state = 797
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def table_name(self):
            return self.getTypedRuleContext(TeradataParser.Table_nameContext,0)


        def DOT(self):
            return self.getToken(TeradataParser.DOT, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_name" ):
                listener.enterColumn_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_name" ):
                listener.exitColumn_name(self)




    def column_name(self):

        localctx = TeradataParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 802
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 799
                self.table_name()
                self.state = 800
                self.match(TeradataParser.DOT)


            self.state = 804
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Correlation_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_correlation_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCorrelation_name" ):
                listener.enterCorrelation_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCorrelation_name" ):
                listener.exitCorrelation_name(self)




    def correlation_name(self):

        localctx = TeradataParser.Correlation_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_correlation_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 806
            self.match(TeradataParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def types(self):
            return self.getTypedRuleContext(TeradataParser.TypesContext,0)


        def OPEN_PAR(self):
            return self.getToken(TeradataParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(TeradataParser.CLOSE_PAR, 0)

        def STRING_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.STRING_LITERAL)
            else:
                return self.getToken(TeradataParser.STRING_LITERAL, i)

        def NUMERIC_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.NUMERIC_LITERAL)
            else:
                return self.getToken(TeradataParser.NUMERIC_LITERAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TeradataParser.COMMA)
            else:
                return self.getToken(TeradataParser.COMMA, i)

        def getRuleIndex(self):
            return TeradataParser.RULE_type_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_name" ):
                listener.enterType_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_name" ):
                listener.exitType_name(self)




    def type_name(self):

        localctx = TeradataParser.Type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_type_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 808
            self.types()
            self.state = 816
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 809
                self.match(TeradataParser.OPEN_PAR)
                self.state = 811 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 810
                    _la = self._input.LA(1)
                    if not(_la==5 or _la==457 or _la==462):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 813 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==5 or _la==457 or _la==462):
                        break

                self.state = 815
                self.match(TeradataParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DATE(self):
            return self.getToken(TeradataParser.K_DATE, 0)

        def K_TIME(self):
            return self.getToken(TeradataParser.K_TIME, 0)

        def K_TIMESTAMP(self):
            return self.getToken(TeradataParser.K_TIMESTAMP, 0)

        def K_INTEGER(self):
            return self.getToken(TeradataParser.K_INTEGER, 0)

        def K_DEC(self):
            return self.getToken(TeradataParser.K_DEC, 0)

        def K_DECIMAL(self):
            return self.getToken(TeradataParser.K_DECIMAL, 0)

        def K_CHAR(self):
            return self.getToken(TeradataParser.K_CHAR, 0)

        def K_CHARACTER(self):
            return self.getToken(TeradataParser.K_CHARACTER, 0)

        def K_VARCHAR(self):
            return self.getToken(TeradataParser.K_VARCHAR, 0)

        def K_FLOAT(self):
            return self.getToken(TeradataParser.K_FLOAT, 0)

        def K_INT(self):
            return self.getToken(TeradataParser.K_INT, 0)

        def K_SMALLINT(self):
            return self.getToken(TeradataParser.K_SMALLINT, 0)

        def K_BIGINT(self):
            return self.getToken(TeradataParser.K_BIGINT, 0)

        def K_BLOB(self):
            return self.getToken(TeradataParser.K_BLOB, 0)

        def K_VARBYTE(self):
            return self.getToken(TeradataParser.K_VARBYTE, 0)

        def K_BYTE(self):
            return self.getToken(TeradataParser.K_BYTE, 0)

        def K_BYTEINT(self):
            return self.getToken(TeradataParser.K_BYTEINT, 0)

        def K_NUMERIC(self):
            return self.getToken(TeradataParser.K_NUMERIC, 0)

        def K_DOUBLE(self):
            return self.getToken(TeradataParser.K_DOUBLE, 0)

        def K_CURSOR(self):
            return self.getToken(TeradataParser.K_CURSOR, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_types

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypes" ):
                listener.enterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypes" ):
                listener.exitTypes(self)




    def types(self):

        localctx = TeradataParser.TypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_types)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            _la = self._input.LA(1)
            if not(((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & 18295892008239105) != 0) or ((((_la - 235)) & ~0x3f) == 0 and ((1 << (_la - 235)) & 69794807817) != 0) or ((((_la - 318)) & ~0x3f) == 0 and ((1 << (_la - 318)) & 576460752303431747) != 0) or _la==428 or _la==451):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TeradataParser.IDENTIFIER, 0)

        def keyword(self):
            return self.getTypedRuleContext(TeradataParser.KeywordContext,0)


        def STRING_LITERAL(self):
            return self.getToken(TeradataParser.STRING_LITERAL, 0)

        def OPEN_PAR(self):
            return self.getToken(TeradataParser.OPEN_PAR, 0)

        def any_name(self):
            return self.getTypedRuleContext(TeradataParser.Any_nameContext,0)


        def CLOSE_PAR(self):
            return self.getToken(TeradataParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return TeradataParser.RULE_any_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAny_name" ):
                listener.enterAny_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAny_name" ):
                listener.exitAny_name(self)




    def any_name(self):

        localctx = TeradataParser.Any_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_any_name)
        try:
            self.state = 827
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [461]:
                self.enterOuterAlt(localctx, 1)
                self.state = 820
                self.match(TeradataParser.IDENTIFIER)
                pass
            elif token in [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451]:
                self.enterOuterAlt(localctx, 2)
                self.state = 821
                self.keyword()
                pass
            elif token in [462]:
                self.enterOuterAlt(localctx, 3)
                self.state = 822
                self.match(TeradataParser.STRING_LITERAL)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 823
                self.match(TeradataParser.OPEN_PAR)
                self.state = 824
                self.any_name()
                self.state = 825
                self.match(TeradataParser.CLOSE_PAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[33] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 2)
         




